{% extends "base.html" %}

{% block title %}Pipeline Management - InferNode{% endblock %}

{% block content %}
<div class="container-fluid">
    <!-- Filter and View Controls -->
    <div class="row mb-3">
        <div class="col-12">
            <div class="d-flex align-items-center justify-content-between gap-3">
                <!-- Left side: Search Box and View Mode -->
                <div class="d-flex align-items-center gap-3">
                    <!-- Search Box -->
                    <div style="width: 30pc;">
                        <div class="input-group">
                            <span class="input-group-text"><i class="fas fa-search"></i></span>
                            <input type="text" class="form-control" id="searchPipelines" placeholder="Search pipelines..." onkeyup="filterPipelines()">
                            <button class="btn btn-outline-secondary" type="button" id="clearSearchBtn" onclick="clearSearch()" title="Clear search">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    
                    <!-- View Mode Buttons -->
                    <div class="btn-group" role="group">
                        <input type="radio" class="btn-check" name="viewMode" id="cardView" autocomplete="off" checked onchange="toggleViewMode('card')">
                        <label class="btn btn-outline-secondary" for="cardView"><i class="fas fa-th-large"></i></label>
                        
                        <input type="radio" class="btn-check" name="viewMode" id="listView" autocomplete="off" onchange="toggleViewMode('list')">
                        <label class="btn btn-outline-secondary" for="listView"><i class="fas fa-list"></i></label>
                    </div>
                </div>
                
                <!-- Right side: Global Controls and Action Buttons -->
<div class="d-flex align-items-center gap-3">
                    <!-- Compact Global Controls -->
                    <div class="d-flex align-items-center gap-3">
                        <!-- Pipeline Controls -->
                        <div class="d-flex align-items-center gap-2">
                            <small class="text-muted" style="font-size: 0.8rem; white-space: nowrap;">Pipelines:</small>
                            <div class="btn-group" role="group">
                                <button type="button" class="btn btn-outline-success btn-sm" onclick="startAllPipelines()" title="Start All Pipelines">
                                    <i class="fas fa-play"></i>
                                </button>
                                <button type="button" class="btn btn-outline-warning btn-sm" onclick="stopAllPipelines()" title="Stop All Pipelines">
                                    <i class="fas fa-stop"></i>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Inference Controls -->
                        <div class="d-flex align-items-center gap-2">
                            <small class="text-muted" style="font-size: 0.8rem; white-space: nowrap;">Inference:</small>
                            <div class="btn-group" role="group">
                                <button type="button" class="btn btn-outline-primary btn-sm" onclick="enableAllInference()" title="Enable All Inference">
                                    <i class="fas fa-brain"></i>
                                </button>
                                <button type="button" class="btn btn-outline-danger btn-sm" onclick="disableAllInference()" title="Disable All Inference">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Preview Controls - Hidden -->
                        <div class="d-flex align-items-center gap-2" style="display: none;">
                            <small class="text-muted" style="font-size: 0.8rem; white-space: nowrap;">Previews:</small>
                            <div class="btn-group" role="group">
                                <button type="button" class="btn btn-outline-primary btn-sm" onclick="showAllPreviews()" title="Show All Previews">
                                    <i class="fas fa-eye"></i>
                                </button>
                                <button type="button" class="btn btn-outline-danger btn-sm" onclick="hideAllPreviews()" title="Hide All Previews">
                                    <i class="fas fa-eye-slash"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Separator -->
                    <div class="vr" style="height: 3rem; opacity: 0.3;"></div>
                    
                    <!-- Action Buttons -->
                    <div class="btn-group" role="group">
                        <button class="btn btn-outline-primary btn-sm" onclick="refreshPipelines()">
                            <i class="fas fa-sync-alt me-1"></i> 
                        </button>
                        <a href="/pipeline-builder" class="btn btn-primary btn-sm">
                            <i class="fas fa-plus me-1"></i>Create Pipeline
                        </a>
                        <button type="button" class="btn btn-primary btn-sm" onclick="importPipeline()">
                            <i class="fas fa-upload me-1"></i>Import Pipeline
                        </button>
                    </div>
                </div>
            </div>
            <!-- Quick Filter Badges -->
            <div class="quick-search-badges mt-2" >
                <span class="quick-search-badge" onclick="toggleQuickFilter('running')" title="Toggle running pipelines filter">
                    <i class="fas fa-play me-1"></i>running
                </span>
                <span class="quick-search-badge" onclick="toggleQuickFilter('stopped')" title="Toggle stopped pipelines filter">
                    <i class="fas fa-stop me-1"></i>stopped
                </span>
                <span class="quick-search-badge" onclick="toggleQuickFilter('error')" title="Toggle error pipelines filter">
                    <i class="fas fa-exclamation-triangle me-1"></i>error
                </span>
                <span class="filter-separator">|</span>
                <!-- Engine filter badges will be populated dynamically by loadAvailableEngineTypes() -->
                <span class="filter-separator">|</span>
                <span class="quick-search-badge" onclick="toggleQuickFilter('webcam')" title="Toggle webcam pipelines filter">
                    <i class="fas fa-video me-1"></i>webcam
                </span>
                <span class="quick-search-badge" onclick="toggleQuickFilter('rtsp')" title="Toggle RTSP/IP camera pipelines filter">
                    <i class="fas fa-wifi me-1"></i>rtsp
                </span>
                <span class="filter-separator">|</span>
                <span class="quick-search-badge" onclick="toggleQuickFilter('mqtt')" title="Toggle MQTT pipelines filter">
                    <i class="fas fa-broadcast-tower me-1"></i>mqtt
                </span>
                <span class="quick-search-badge" onclick="toggleQuickFilter('webhook')" title="Toggle Webhook pipelines filter">
                    <i class="fas fa-link me-1"></i>webhook
                </span>
                <span class="filter-separator">|</span>
                <span class="quick-search-badge" onclick="toggleQuickFilter('cpu')" title="Toggle CPU pipelines filter">
                    <i class="fas fa-microchip me-1"></i>cpu
                </span>
                <span class="quick-search-badge" onclick="toggleQuickFilter('gpu')" title="Toggle GPU pipelines filter">
                    <i class="fas fa-memory me-1"></i>gpu
                </span>
                <span class="quick-search-badge" onclick="toggleQuickFilter('npu')" title="Toggle NPU pipelines filter">
                    <i class="fas fa-brain me-1"></i>npu
                </span>
            </div>
        </div>
    </div>

    <!-- Pipelines Container -->
    <div id="pipelinesContainer">
        <!-- Card View Container -->
        <div id="cardViewContainer" class="row g-3">
            <!-- Pipeline cards will be inserted here -->
        </div>
        
        <!-- List View Container -->
        <div id="listViewContainer" style="display: none;">
            <div class="table-responsive">
                <table class="table table-hover">
                    <thead class="table-dark">
                        <tr>
                            <th>Name</th>
                            <th>Status</th>
                            <th>Inference</th>
                            <th>Source</th>
                            <th>Model/Engine</th>
                            <th>Device</th>
                            <th>Destinations</th>
                            <th>FPS</th>
                            <th>Latency</th>
                            <th>Uptime</th>
                            <th>Created</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="pipelineTableBody">
                        <!-- Pipeline rows will be inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loadingIndicator" class="text-center py-4" style="display: none;">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2 text-muted">Loading pipelines...</p>
    </div>

    <!-- Empty State -->
    <div id="emptyState" class="text-center py-5" style="display: none;">
        <div style="font-size: 3rem; margin-bottom: 1rem;">ðŸ¤·</div>
        <h5 class="text-muted">No Pipelines Found</h5>
        <p class="text-muted">Create your first pipeline to get started with inference processing.</p>
        <a href="/pipeline-builder" class="btn btn-primary">
            <i class="fas fa-plus me-1"></i>Create Pipeline
        </a>
    </div>
</div>

<!-- List View Preview Overlay -->
<div id="listPreviewOverlay" class="list-preview-overlay">
    <img id="listPreviewImage" src="" alt="Pipeline Preview">
    <div id="listPreviewStatus" class="preview-status">Connecting...</div>
</div>

<!-- Pipeline Details Modal -->
<div class="modal fade" id="pipelineDetailsModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-info-circle me-2"></i>Pipeline Details
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="pipelineDetailsContent">
                <!-- Pipeline details will be loaded here -->
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" id="editPipelineBtn" onclick="editPipeline()">
                    <i class="fas fa-edit me-1"></i>Edit Pipeline
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Full Preview Modal -->
<div class="modal fade" id="fullPreviewModal" tabindex="-1">
    <div class="modal-dialog modal-fullscreen">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-eye me-2"></i>Pipeline Preview: <span id="fullPreviewTitle">Loading...</span>
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body d-flex justify-content-center align-items-center">
                <img id="fullPreviewStream" src="" style="max-width: 100%; max-height: 100%; object-fit: contain;" />
            </div>
            <div class="modal-footer">
                <div id="fullPreviewStatus" class="me-auto">
                    <small class="text-muted">Loading stream...</small>
                </div>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Hidden file input for pipeline import -->
<input type="file" id="pipelineImportInput" accept=".zip" style="display: none;" />

{% endblock %}

{% block scripts %}
<style>
/* Optimize video streaming performance */
.preview-stream {
    will-change: transform; /* Hint to browser for GPU acceleration */
    transform: translateZ(0); /* Force hardware acceleration */
    backface-visibility: hidden; /* Optimize for animations */
    image-rendering: optimizeSpeed; /* Prioritize speed over quality */
    transition: opacity 0.2s ease-in-out; /* Smooth fade transitions */
    opacity: 0; /* Start invisible for fade-in effect */
}

.preview-stream.loaded {
    opacity: 1;
}

/* Optimize preview containers */
.preview-container {
    contain: layout style paint; /* CSS containment for better performance */
    transform: translateZ(0); /* Force hardware acceleration */
}

/* Optimize full preview */
#fullPreviewStream {
    will-change: transform;
    transform: translateZ(0);
    image-rendering: optimizeQuality; /* Higher quality for full preview */
    transition: opacity 0.3s ease-in-out;
}

/* Improve pipeline info typography */
.pipeline-card .fw-bold {
    font-weight: 600 !important;
    color: #495057 !important;
}

.pipeline-card .text-muted.fw-bold {
    color: #6c757d !important;
}

/* Destination badges styling */
.destination-badges .badge {
    font-size: 0.7rem;
    margin-right: 2px;
    margin-bottom: 2px;
}

/* List view preview overlay */
.list-preview-overlay {
    position: fixed;
    z-index: 1060;
    background: rgba(0, 0, 0, 0.9);
    border-radius: 8px;
    padding: 10px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    max-width: 400px;
    max-height: 300px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    transform: translateZ(0);
}

.list-preview-overlay.show {
    opacity: 1;
}

.list-preview-overlay img {
    max-width: 100%;
    max-height: 280px;
    object-fit: contain;
    border-radius: 4px;
}

.list-preview-overlay .preview-status {
    color: white;
    font-size: 0.8rem;
    text-align: center;
    margin-top: 5px;
}

/* List view row hover effect for preview-enabled rows */
tr.preview-enabled:hover {
    background-color: rgba(0, 123, 255, 0.05) !important;
    cursor: pointer;
}

/* Prevent URL wrapping on pipeline cards to maintain alignment */
.pipeline-card .text-muted {
    word-break: break-all;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 100%;
}

/* Ensure source details don't wrap and cause misalignment */
.pipeline-card .source-details {
    font-size: 0.8rem;
    word-break: break-all;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    line-clamp: 2;
    -webkit-box-orient: vertical;
    max-height: 2.4em;
    line-height: 1.2;
}

/* Inference Toggle Switch Styles - Apple Style */
.inference-toggle {
    position: relative;
    width: 50px;
    height: 25px;
    margin: 0;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

.inference-toggle input {
    opacity: 0;
    width: 0;
    height: 0;
}

.inference-slider {
    position: absolute;
    top: 0;
    left: 0;
    width: 50px;
    height: 25px;
    border-radius: 50px;
    background: linear-gradient(to bottom, #b3b3b3, #e6e6e6);
    cursor: pointer;
    transition: all 0.3s ease;
}

.inference-slider:after {
    content: '';
    position: absolute;
    top: 1px;
    left: 1px;
    width: 23px;
    height: 23px;
    border-radius: 50%;
    background-color: #fff;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
}

.inference-toggle input:checked + .inference-slider {
    background: linear-gradient(to bottom, #198754, #146c43);
}

.inference-toggle input:checked + .inference-slider:after {
    transform: translateX(25px);
}

.inference-slider:hover {
    background: linear-gradient(to bottom, #b3b3b3, #e6e6e6);
}

.inference-slider:hover:after {
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.inference-toggle input:disabled + .inference-slider {
    background: linear-gradient(to bottom, #6c757d, #868e96);
    cursor: not-allowed;
    opacity: 0.6;
}

/* Compact toggle for list view */
.inference-toggle.compact {
    width: 40px;
    height: 20px;
    margin: 10px;
}

.inference-toggle.compact .inference-slider {
    width: 40px;
    height: 20px;
}

.inference-toggle.compact .inference-slider:after {
    width: 18px;
    height: 18px;
}

.inference-toggle.compact input:checked + .inference-slider:after {
    transform: translateX(20px);
}

/* Preview Toggle Switch Styles - Apple Style - HIDDEN */
.preview-toggle {
    display: none !important; /* Completely hide all preview toggles */
    position: relative;
    width: 50px;
    height: 25px;
    margin: 0;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* Hide any preview-related elements in card footers */
.card-footer .preview-toggle {
    display: none !important;
}

.preview-toggle input {
    opacity: 0;
    width: 0;
    height: 0;
}

.preview-slider {
    position: absolute;
    top: 0;
    left: 0;
    width: 50px;
    height: 25px;
    border-radius: 50px;
    background: linear-gradient(to bottom, #b3b3b3, #e6e6e6);
    cursor: pointer;
    transition: all 0.3s ease;
}

.preview-slider:after {
    content: '';
    position: absolute;
    top: 1px;
    left: 1px;
    width: 23px;
    height: 23px;
    border-radius: 50%;
    background-color: #fff;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
}

.preview-toggle input:checked + .preview-slider {
    background: linear-gradient(to bottom, #198754, #146c43);
}

.preview-toggle input:checked + .preview-slider:after {
    transform: translateX(25px);
}

.preview-slider:hover {
    background: linear-gradient(to bottom, #b3b3b3, #e6e6e6);
}

.preview-slider:hover:after {
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.preview-toggle input:disabled + .preview-slider {
    background: linear-gradient(to bottom, #6c757d, #868e96);
    cursor: not-allowed;
    opacity: 0.6;
}

/* Compact preview toggle for list view */
.preview-toggle.compact {
    width: 40px;
    height: 20px;
    margin: 10px;
}

.preview-toggle.compact .preview-slider {
    width: 40px;
    height: 20px;
}

.preview-toggle.compact .preview-slider:after {
    width: 18px;
    height: 18px;
}

.preview-toggle.compact input:checked + .preview-slider:after {
    transform: translateX(20px);
}

/* Pipeline info badges styling */
.pipeline-info-badges {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-bottom: 8px;
}

/* Quick filter badges */
.quick-search-badges {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-left: 0;
}

.quick-search-badge {
    background-color: #495057;
    color: #adb5bd;
    border: 1px solid #6c757d;
    padding: 3px 10px;
    font-size: 0.75rem;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    user-select: none;
    display: inline-flex;
    align-items: center;
}

.quick-search-badge:hover {
    background-color: #6c757d;
    color: #ffffff;
    border-color: #adb5bd;
}

.quick-search-badge.active {
    background-color: #0d6efd;
    color: #ffffff;
    border-color: #0d6efd;
}

.quick-search-badge.clear-filter {
    background-color: #dc3545;
    border-color: #dc3545;
}

.quick-search-badge.clear-filter:hover {
    background-color: #c82333;
    border-color: #bd2130;
}

.filter-separator {
    color: #6c757d;
    font-size: 0.9rem;
    padding: 0 8px;
    display: inline-flex;
    align-items: center;
    user-select: none;
}

/* Small Destination Toggle Switch Styles for Publisher Controls */
.destination-toggle-small {
    position: relative;
    width: 32px;
    height: 16px;
    margin: 0;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

.destination-toggle-small input {
    opacity: 0;
    width: 0;
    height: 0;
}

.destination-slider-small {
    position: absolute;
    top: 0;
    left: 0;
    width: 32px;
    height: 16px;
    border-radius: 16px;
    background: linear-gradient(to bottom, #b3b3b3, #e6e6e6);
    cursor: pointer;
    transition: all 0.3s ease;
}

.destination-slider-small:after {
    content: '';
    position: absolute;
    top: 1px;
    left: 1px;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background-color: #fff;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
}

.destination-toggle-small input:checked + .destination-slider-small {
    background: linear-gradient(to bottom, #198754, #146c43);
}

.destination-toggle-small input:checked + .destination-slider-small:after {
    transform: translateX(16px);
}

.destination-slider-small:hover {
    background: linear-gradient(to bottom, #a0a0a0, #d0d0d0);
}

.destination-toggle-small input:checked + .destination-slider-small:hover {
    background: linear-gradient(to bottom, #157347, #0d5132);
}

.destination-slider-small:hover:after {
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
}

.destination-toggle-small input:disabled + .destination-slider-small {
    background: linear-gradient(to bottom, #6c757d, #868e96);
    cursor: not-allowed;
    opacity: 0.6;
}
/* Prevent hover color change when disabled */
.destination-toggle-small input:disabled + .destination-slider-small:hover {
    background: linear-gradient(to bottom, #6c757d, #868e96);
}

/* Paused state styling - orange/amber glow for paused destinations */
.destination-toggle-small.paused .destination-slider-small {
    background: linear-gradient(to bottom, #ffc107, #ffb300);
    animation: pulse-paused 2s ease-in-out infinite;
}

@keyframes pulse-paused {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.7;
    }
}

/* Thumbnail styling */
.thumbnail-placeholder {
    background-color: #1a1a1a;
}

.thumbnail-image {
    background-color: #1a1a1a;
    filter: brightness(0.9); /* Slightly dimmed to distinguish from live preview */
    transition: filter 0.2s ease;
}

.thumbnail-placeholder:hover .thumbnail-image {
    filter: brightness(1.0); /* Brighten on hover */
}

.thumbnail-overlay {
    background: linear-gradient(135deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.5) 100%);
    border-radius: 0 4px 0 4px;
}

/* Modern play/pause button overlay */
.preview-hover-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.3);
    opacity: 0;
    transition: opacity 0.3s ease;
    cursor: pointer;
    z-index: 3;
}

.preview-hover-overlay:hover {
    opacity: 1;
}

/* Message overlay for stopped pipelines */
.preview-message-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.7);
    opacity: 0;
    transition: opacity 0.3s ease;
    cursor: default;
    z-index: 3;
}

.preview-message-overlay:hover {
    opacity: 1;
}

.preview-message-text {
    background: rgba(255, 255, 255, 0.95);
    color: #333;
    padding: 12px 20px;
    border-radius: 8px;
    font-size: 0.9rem;
    font-weight: 500;
    text-align: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transform: scale(0.9);
    transition: transform 0.2s ease;
}

.preview-message-overlay:hover .preview-message-text {
    transform: scale(1);
}

/* Don't show hover overlay on the expand button area */
.preview-overlay {
    position: relative;
    z-index: 4;
    pointer-events: auto;
}

.preview-play-button {
    width: 80px;
    height: 80px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    transform: scale(0.8);
    transition: all 0.2s ease;
}

.preview-hover-overlay:hover .preview-play-button {
    transform: scale(1);
    background: rgba(255, 255, 255, 1);
}

.preview-play-button i {
    font-size: 2rem;
    color: #333;
}

/* Adjust play icon position slightly for visual balance */
.preview-play-button .fa-play {
    margin-left: 4px;
}

/* Different styling for stopped vs running vs error pipelines */
.thumbnail-placeholder[data-pipeline-status="stopped"] .preview-hover-overlay {
    background: rgba(40, 167, 69, 0.2);
}

.thumbnail-placeholder[data-pipeline-status="starting"] .preview-hover-overlay {
    background: rgba(255, 193, 7, 0.2);
}

.thumbnail-placeholder[data-pipeline-status="running"] .preview-hover-overlay {
    background: rgba(0, 0, 0, 0.3);
}

.thumbnail-placeholder[data-pipeline-status="error"] .preview-hover-overlay {
    background: rgba(220, 53, 69, 0.2);
}
</style>
<script>
let allPipelines = [];
let filteredPipelines = [];
let currentViewMode = localStorage.getItem('pipelineViewMode') || 'card'; // Load saved preference or default to card
let activePreviews = new Set(); // Track which previews are currently active
let currentDetailPipelineId = null;
let availableEngineTypes = []; // Track available inference engines

// Alert function now handled by centralized notification system in app.js

// Load and refresh pipelines
async function refreshPipelines(preservePreviews = false) {
    // Save current preview state if preserving
    let savedPreviews = new Set();
    if (preservePreviews) {
        savedPreviews = new Set(activePreviews);
    } else {
        document.getElementById('loadingIndicator').style.display = 'block';
        document.getElementById('pipelinesContainer').style.display = 'none';
        document.getElementById('emptyState').style.display = 'none';
    }
    
    try {
        const response = await fetch('/api/pipelines');
        const data = await response.json();
        
        if (response.ok) {
            allPipelines = data.pipelines || [];
            
            if (preservePreviews) {
                // Update pipeline data but preserve UI state
                updatePipelineData(savedPreviews);
            } else {
                filterPipelines();
            }
        } else {
            showAlert('error', 'Failed to load pipelines: ' + data.error);
            allPipelines = [];
        }
    } catch (error) {
        showAlert('error', 'Error loading pipelines: ' + error.message);
        allPipelines = [];
    } finally {
        if (!preservePreviews) {
            document.getElementById('loadingIndicator').style.display = 'none';
        }
    }
}

// Update pipeline data without re-rendering the entire view (preserves previews)
function updatePipelineData(savedPreviews) {
    // Update filtered pipelines
    const searchTerm = document.getElementById('searchPipelines').value.toLowerCase();
    
    // Get active filters from the quick filter set
    const statusFilters = ['running', 'starting', 'stopped', 'error'].filter(status => activeQuickFilters.has(status));
    const engineFilters = availableEngineTypes.map(e => e.type).filter(engine => activeQuickFilters.has(engine));
    const sourceFilters = ['webcam', 'rtsp', 'ip_camera'].filter(source => activeQuickFilters.has(source));
    const destinationFilters = ['mqtt', 'webhook'].filter(dest => activeQuickFilters.has(dest));
    const hardwareFilters = ['cpu', 'gpu', 'npu'].filter(hardware => activeQuickFilters.has(hardware));
    
    filteredPipelines = allPipelines.filter(pipeline => {
        const matchesSearch = !searchTerm || 
            pipeline.name.toLowerCase().includes(searchTerm) ||
            (pipeline.description || '').toLowerCase().includes(searchTerm) ||
            // Search in status
            (pipeline.status || '').toLowerCase().includes(searchTerm) ||
            // Search in frame source type
            (pipeline.frame_source?.capture_type || pipeline.frame_source?.type || '').toLowerCase().includes(searchTerm) ||
            // Search in model information
            (pipeline.model?.engine_type || '').toLowerCase().includes(searchTerm) ||
            (pipeline.model?.id || '').toLowerCase().includes(searchTerm) ||
            // Search in device information
            (pipeline.model?.device || '').toLowerCase().includes(searchTerm) ||
            // Search in result destinations
            (pipeline.result_destinations && pipeline.result_destinations.some(dest => 
                (dest.type || '').toLowerCase().includes(searchTerm) ||
                (dest.destination_type || '').toLowerCase().includes(searchTerm) ||
                (dest.config?.host || '').toLowerCase().includes(searchTerm) ||
                (dest.config?.topic || '').toLowerCase().includes(searchTerm) ||
                (dest.config?.url || '').toLowerCase().includes(searchTerm)
            )) ||
            // Also search in destinations array if it exists
            (pipeline.destinations && pipeline.destinations.some(dest => 
                (dest.type || '').toLowerCase().includes(searchTerm) ||
                (dest.destination_type || '').toLowerCase().includes(searchTerm)
            ));
        
        const matchesStatus = statusFilters.length === 0 || statusFilters.includes(pipeline.status);
        
        const matchesEngine = engineFilters.length === 0 || 
            (pipeline.model && engineFilters.includes(pipeline.model.engine_type));
        
        const matchesSource = sourceFilters.length === 0 || 
            sourceFilters.some(source => 
                (pipeline.frame_source?.capture_type || pipeline.frame_source?.type || '').toLowerCase().includes(source)
            );
        
        const matchesDestination = destinationFilters.length === 0 || 
            (pipeline.result_destinations && pipeline.result_destinations.some(dest => {
                return destinationFilters.includes(dest.type?.toLowerCase()) || 
                       destinationFilters.includes(dest.destination_type?.toLowerCase());
            })) ||
            (pipeline.destinations && pipeline.destinations.some(dest => {
                return destinationFilters.includes(dest.type?.toLowerCase()) || 
                       destinationFilters.includes(dest.destination_type?.toLowerCase());
            }));
        
        const matchesHardware = hardwareFilters.length === 0 || 
            (pipeline.model && pipeline.model.device && 
             hardwareFilters.some(hardware => pipeline.model.device.toLowerCase().includes(hardware)));
        
        return matchesSearch && matchesStatus && matchesEngine && matchesSource && matchesDestination && matchesHardware;
    });
    
    // Update quick filter badge visual states to preserve active filters
    updateQuickFilterBadges();
    
    // Update individual pipeline cards/rows without full re-render
    filteredPipelines.forEach(pipeline => {
        updatePipelineUI(pipeline, savedPreviews);
    });
    
    // Remove pipelines that no longer exist or match filters
    const currentPipelineIds = new Set(filteredPipelines.map(p => p.id));
    const previewsToRemove = [];
    activePreviews.forEach(pipelineId => {
        if (!currentPipelineIds.has(pipelineId)) {
            previewsToRemove.push(pipelineId);
        }
    });
    
    // Clean up previews for removed/filtered pipelines
    previewsToRemove.forEach(pipelineId => {
        stopPreviewStream(pipelineId);
        activePreviews.delete(pipelineId);
    });
    
    // If we have new pipelines to render (view switched or new pipelines added)
    const existingPipelineIds = new Set(Array.from(document.querySelectorAll('[data-pipeline-id]')).map(el => el.getAttribute('data-pipeline-id')));
    const needsFullRender = filteredPipelines.some(p => !existingPipelineIds.has(p.id)) || 
                            Array.from(existingPipelineIds).some(id => !currentPipelineIds.has(id));
    
    if (needsFullRender) {
        // Need to do a full render but preserve active previews
        if (currentViewMode === 'card') {
            renderCardView();
        } else {
            renderListView();
        }
        
        // Restore previews after render
        savedPreviews.forEach(pipelineId => {
            if (currentPipelineIds.has(pipelineId)) {
                const pipeline = filteredPipelines.find(p => p.id === pipelineId);
                if (pipeline && pipeline.status === 'running') {
                    startPreviewStream(pipelineId);
                }
            }
        });
    }
    
    // Show empty state if needed
    if (filteredPipelines.length === 0) {
        document.getElementById('pipelinesContainer').style.display = 'none';
        document.getElementById('emptyState').style.display = 'block';
    } else {
        document.getElementById('pipelinesContainer').style.display = 'block';
        document.getElementById('emptyState').style.display = 'none';
    }
}

// Update individual pipeline UI elements without destroying previews
function updatePipelineUI(pipeline, savedPreviews) {
    const statusColor = getStatusColor(pipeline.status);
    
    // Stop preview streams for non-running pipelines (stopped or error)
    if (pipeline.status !== 'running' && activePreviews.has(pipeline.id)) {
        stopPreviewStream(pipeline.id);
        activePreviews.delete(pipeline.id);
    }
    
    // Update status badges
    const cardElement = document.querySelector(`[data-pipeline-id="${pipeline.id}"]`);
    if (cardElement) {
        // Update status badge in card view
        const statusBadge = cardElement.querySelector('.badge');
        if (statusBadge) {
            statusBadge.className = `badge bg-${statusColor} badge-sm`;
            statusBadge.textContent = capitalizeStatus(pipeline.status);
        }
        
        // Update inference badge in card view
        const inferenceBadge = cardElement.querySelector('.badge:nth-child(2)');
        if (inferenceBadge) {
            if (pipeline.status === 'running') {
                const isInferenceEnabled = (pipeline.inference_enabled === true || pipeline.inference_enabled === undefined);
                inferenceBadge.className = `badge ${isInferenceEnabled ? 'bg-info' : 'bg-secondary'} badge-sm`;
                inferenceBadge.innerHTML = `
                    <i class="fas fa-brain me-1"></i>
                    ${isInferenceEnabled ? 'Inference ON' : 'Inference OFF'}
                `;
                inferenceBadge.style.display = '';
            } else {
                // Hide the inference badge when pipeline is not running (stopped, error, etc.)
                inferenceBadge.style.display = 'none';
            }
        }
        
        // Update action buttons
        const startStopBtn = cardElement.querySelector('.card-footer button:first-child');
        if (startStopBtn) {
            startStopBtn.className = `btn btn-sm ${pipeline.status === 'running' ? 'btn-warning' : 'btn-success'}`;
            startStopBtn.innerHTML = `<i class="fas fa-${pipeline.status === 'running' ? 'stop' : 'play'} me-1"></i>${pipeline.status === 'running' ? 'Stop' : 'Start'}`;
            startStopBtn.onclick = () => pipeline.status === 'running' ? stopPipeline(pipeline.id) : startPipeline(pipeline.id);
        }
        
        // Update inference toggle switch in card view
        const inferenceToggle = cardElement.querySelector('.inference-toggle input');
        if (inferenceToggle) {
            inferenceToggle.checked = (pipeline.inference_enabled === true || pipeline.inference_enabled === undefined);
            inferenceToggle.disabled = pipeline.status !== 'running';
        }
        
        // Update preview toggle switch in card view - DISABLED (preview toggles are hidden)
        /*
        const previewToggle = cardElement.querySelector('.preview-toggle input');
        if (previewToggle) {
            const isPreviewActive = activePreviews.has(pipeline.id);
            previewToggle.checked = isPreviewActive;
            previewToggle.disabled = pipeline.status !== 'running';
            if (pipeline.status !== 'running' && savedPreviews.has(pipeline.id)) {
                // Pipeline stopped, remove preview
                stopPreviewStream(pipeline.id);
                activePreviews.delete(pipeline.id);
            }
            // Update preview container visibility
            updatePreviewContainerVisibility(pipeline.id, isPreviewActive && pipeline.status === 'running');
        }
        */
    }
    
    // Update list view row
    const rowElement = document.querySelector(`tr[data-pipeline-id="${pipeline.id}"]`);
    if (rowElement) {
        // Update status in list view
        const listStatusBadge = rowElement.querySelector('td:nth-child(2) .badge');
        if (listStatusBadge) {
            listStatusBadge.className = `badge bg-${statusColor}`;
            listStatusBadge.textContent = capitalizeStatus(pipeline.status);
        }
        
        // Update inference toggle switch in list view
        const inferenceCell = rowElement.querySelector('td:nth-child(3)');
        if (inferenceCell) {
            if (pipeline.status === 'running') {
                const isInferenceEnabled = (pipeline.inference_enabled === true || pipeline.inference_enabled === undefined);
                inferenceCell.innerHTML = `
                    <div class="d-flex align-items-center justify-content-center">
                        <label class="inference-toggle compact">
                            <input type="checkbox" 
                                   ${isInferenceEnabled ? 'checked' : ''} 
                                   onchange="toggleInference('${pipeline.id}', this.checked)">
                            <span class="inference-slider"></span>
                        </label>
                    </div>
                `;
            } else {
                inferenceCell.innerHTML = '<span class="text-muted">-</span>';
            }
        }
        
        // Update preview toggle switch in list view - DISABLED (preview toggles are hidden)
        /*
        const previewCell = rowElement.querySelector('td:nth-child(4)');
        if (previewCell) {
            if (pipeline.status === 'running') {
                const isPreviewActive = activePreviews.has(pipeline.id);
                previewCell.innerHTML = `
                    <label class="preview-toggle compact">
                        <input type="checkbox" 
                               ${isPreviewActive ? 'checked' : ''} 
                               onchange="togglePreviewSwitch('${pipeline.id}', this.checked)">
                        <span class="preview-slider"></span>
                    </label>
                `;
            } else {
                previewCell.innerHTML = '<span class="text-muted">-</span>';
            }
        }
        */

        // Update action buttons in list view
        const actionsCell = rowElement.querySelector('td:last-child .btn-group');
        if (actionsCell && pipeline.status === 'running') {
            // Actions are now just start/stop, details, edit, delete - no more preview button
        }
        
        // Update row hover functionality for preview
        const isActive = activePreviews.has(pipeline.id);
        if (isActive) {
            rowElement.className = 'preview-enabled';
            rowElement.onmouseenter = () => showListPreview(pipeline.id);
            rowElement.onmouseleave = () => hideListPreview();
        } else {
            rowElement.className = '';
            rowElement.onmouseenter = null;
            rowElement.onmouseleave = null;
        }
    }
    
    // Update hover overlays for the new status
    updateHoverOverlays(pipeline.id, pipeline.status);
}

// Set button loading state with spinner and optional text
function setButtonLoadingState(pipelineId, isLoading, loadingText = 'Starting...') {
    // Update card view button
    const cardButton = document.querySelector(`[data-pipeline-id="${pipelineId}"] .card-footer button`);
    if (cardButton) {
        if (isLoading) {
            cardButton.disabled = true;
            cardButton.innerHTML = `<i class="fas fa-spinner fa-spin me-1"></i>${loadingText}`;
            cardButton.classList.remove('btn-success', 'btn-warning');
            cardButton.classList.add('btn-secondary');
        } else {
            cardButton.disabled = false;
            // The button content will be updated by updateSinglePipelineState
        }
    }
    
    // Update list view button
    const listButton = document.querySelector(`tr[data-pipeline-id="${pipelineId}"] .btn-group button:first-child`);
    if (listButton) {
        if (isLoading) {
            listButton.disabled = true;
            listButton.innerHTML = `<i class="fas fa-spinner fa-spin"></i>`;
            listButton.classList.remove('btn-success', 'btn-warning');
            listButton.classList.add('btn-secondary');
            listButton.title = loadingText;
        } else {
            listButton.disabled = false;
            // The button content will be updated by updateSinglePipelineState
        }
    }
}

// Update a single pipeline's state without full refresh (prevents scrolling and preview interruption)
function updateSinglePipelineState(pipelineId, newStatus) {
    // Find the pipeline in our current data
    const pipeline = allPipelines.find(p => p.id === pipelineId);
    if (!pipeline) return;
    
    // Update the pipeline status in our local data
    pipeline.status = newStatus;
    pipeline.inference_enabled = newStatus === 'running' ? pipeline.inference_enabled : false;
    
    // Stop preview streams for non-running pipelines (stopped or error)
    if (newStatus !== 'running' && activePreviews.has(pipelineId)) {
        stopPreviewStream(pipelineId);
        activePreviews.delete(pipelineId);
    }
    
    // Update UI elements for this specific pipeline
    const statusColor = getStatusColor(newStatus);
    
    // Update card view elements
    const cardElement = document.querySelector(`[data-pipeline-id="${pipelineId}"]`);
    if (cardElement) {
        // Update status badge
        const statusBadge = cardElement.querySelector('.badge');
        if (statusBadge) {
            statusBadge.className = `badge bg-${statusColor} badge-sm`;
            statusBadge.textContent = capitalizeStatus(newStatus);
        }
        
        // Update inference badge in card header
        const inferenceBadge = cardElement.querySelector('.badge:nth-child(2)');
        if (inferenceBadge) {
            if (newStatus === 'running') {
                const isInferenceEnabled = (pipeline.inference_enabled === true || pipeline.inference_enabled === undefined);
                inferenceBadge.className = `badge ${isInferenceEnabled ? 'bg-info' : 'bg-secondary'} badge-sm`;
                inferenceBadge.innerHTML = `
                    <i class="fas fa-brain me-1"></i>
                    ${isInferenceEnabled ? 'Inference ON' : 'Inference OFF'}
                `;
                inferenceBadge.style.display = '';
            } else {
                inferenceBadge.style.display = 'none';
            }
        }
        
        // Update start/stop button
        const startStopBtn = cardElement.querySelector('.card-footer button:first-child');
        if (startStopBtn) {
            if (newStatus === 'starting') {
                startStopBtn.className = 'btn btn-sm btn-secondary';
                startStopBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Starting...';
                startStopBtn.disabled = true;
                startStopBtn.onclick = null;
            } else {
                startStopBtn.className = `btn btn-sm ${newStatus === 'running' ? 'btn-warning' : 'btn-success'}`;
                startStopBtn.innerHTML = `<i class="fas fa-${newStatus === 'running' ? 'stop' : 'play'} me-1"></i>${newStatus === 'running' ? 'Stop' : 'Start'}`;
                startStopBtn.disabled = false;
                startStopBtn.onclick = () => newStatus === 'running' ? stopPipeline(pipelineId) : startPipeline(pipelineId);
            }
        }
        
        // Update inference toggle switch state (always visible, enable/disable based on status)
        const inferenceToggle = cardElement.querySelector('.inference-toggle input');
        if (inferenceToggle) {
            if (newStatus === 'running') {
                inferenceToggle.disabled = false;
                inferenceToggle.checked = (pipeline.inference_enabled === true || pipeline.inference_enabled === undefined);
            } else {
                inferenceToggle.disabled = true;
                inferenceToggle.checked = (newStatus === 'starting') ? (pipeline.inference_enabled === true || pipeline.inference_enabled === undefined) : false;
            }
        }
        
        // Update preview toggle switch state - DISABLED (preview toggles are hidden)
        /*
        const previewToggle = cardElement.querySelector('.preview-toggle input');
        if (previewToggle) {
            if (newStatus === 'running') {
                previewToggle.disabled = false;
                const isActive = activePreviews.has(pipelineId);
                previewToggle.checked = isActive;
                updatePreviewContainerVisibility(pipelineId, isActive);
            } else {
                previewToggle.disabled = true;
                previewToggle.checked = false;
                // For stopped pipelines, hide live preview but don't call updatePreviewContainerVisibility
                // as it might interfere with thumbnail display
                const previewContainer = cardElement.querySelector(`#preview-${pipelineId}`);
                if (previewContainer) {
                    previewContainer.style.display = 'none';
                }
            }
        }
        */
        
        // Update destination toggle switches state (enable/disable based on status)
        const destinationToggles = cardElement.querySelectorAll('.destination-toggle-small input');
        if (destinationToggles) {
            destinationToggles.forEach(toggle => {
                if (newStatus === 'running') {
                    toggle.disabled = false;
                } else {
                    toggle.disabled = true;
                }
            });
        }
        
        // Reset metrics when pipeline stops (but not during starting)
        if (newStatus !== 'running' && newStatus !== 'starting') {
            const fpsElement = cardElement.querySelector(`#fps-${pipelineId}`);
            const latencyElement = cardElement.querySelector(`#latency-${pipelineId}`);
            const framesElement = cardElement.querySelector(`#frames-${pipelineId}`);
            const uptimeElement = cardElement.querySelector(`#uptime-${pipelineId}`);
            
            if (fpsElement) fpsElement.textContent = '0.0';
            if (latencyElement) latencyElement.textContent = '0ms';
            if (framesElement) framesElement.textContent = '0';
            if (uptimeElement) uptimeElement.textContent = '0s';
        }
    }
    
    // Update list view elements
    const rowElement = document.querySelector(`tr[data-pipeline-id="${pipelineId}"]`);
    if (rowElement) {
        // Update status badge
        const listStatusBadge = rowElement.querySelector('td:nth-child(2) .badge');
        if (listStatusBadge) {
            listStatusBadge.className = `badge bg-${statusColor}`;
            listStatusBadge.textContent = capitalizeStatus(newStatus);
        }
        
        // Update inference cell with toggle switch
        const inferenceCell = rowElement.querySelector('td:nth-child(3)');
        if (inferenceCell) {
            if (newStatus === 'running') {
                const isInferenceEnabled = (pipeline.inference_enabled === true || pipeline.inference_enabled === undefined);
                inferenceCell.innerHTML = `
                    <label class="inference-toggle compact">
                        <input type="checkbox" 
                               ${isInferenceEnabled ? 'checked' : ''} 
                               onchange="toggleInference('${pipelineId}', this.checked)">
                        <span class="inference-slider"></span>
                    </label>
                `;
            } else if (newStatus === 'starting') {
                const isInferenceEnabled = (pipeline.inference_enabled === true || pipeline.inference_enabled === undefined);
                inferenceCell.innerHTML = `
                    <label class="inference-toggle compact">
                        <input type="checkbox" 
                               ${isInferenceEnabled ? 'checked' : ''} 
                               disabled
                               onchange="toggleInference('${pipelineId}', this.checked)">
                        <span class="inference-slider"></span>
                    </label>
                `;
            } else {
                inferenceCell.innerHTML = '<span class="text-muted">-</span>';
            }
        }
        
        // Update preview cell with toggle switch - DISABLED (preview toggles are hidden)
        /*
        const previewCell = rowElement.querySelector('td:nth-child(4)');
        if (previewCell) {
            if (newStatus === 'running') {
                const isPreviewActive = activePreviews.has(pipelineId);
                previewCell.innerHTML = `
                    <label class="preview-toggle compact">
                        <input type="checkbox" 
                               ${isPreviewActive ? 'checked' : ''} 
                               onchange="togglePreviewSwitch('${pipelineId}', this.checked)">
                        <span class="preview-slider"></span>
                    </label>
                `;
            } else {
                previewCell.innerHTML = '<span class="text-muted">-</span>';
            }
        }
        */

        // Update FPS cell (now column 8)
        const fpsCell = rowElement.querySelector('td:nth-child(8)');
        if (fpsCell) {
            if (newStatus === 'running') {
                fpsCell.innerHTML = `<span class="text-info" id="list-fps-${pipelineId}">0.0</span>`;
            } else {
                fpsCell.innerHTML = `<span class="text-info" id="list-fps-${pipelineId}">0.0</span>`;
            }
        }
        
        // Update Uptime cell (now column 10)
        const uptimeCell = rowElement.querySelector('td:nth-child(10)');
        if (uptimeCell) {
            if (newStatus === 'running') {
                uptimeCell.innerHTML = `<span class="text-success" id="list-uptime-${pipelineId}">0s</span>`;
            } else {
                uptimeCell.innerHTML = `<span class="text-success" id="list-uptime-${pipelineId}">0s</span>`;
            }
        }
        
        // Update action buttons
        const actionsCell = rowElement.querySelector('td:last-child .btn-group');
        if (actionsCell) {
            const startStopBtn = actionsCell.querySelector('button:first-child');
            if (startStopBtn) {
                if (newStatus === 'starting') {
                    startStopBtn.className = 'btn btn-secondary';
                    startStopBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                    startStopBtn.title = 'Starting...';
                    startStopBtn.disabled = true;
                    startStopBtn.onclick = null;
                } else {
                    startStopBtn.className = `btn ${newStatus === 'running' ? 'btn-warning' : 'btn-success'}`;
                    startStopBtn.innerHTML = `<i class="fas fa-${newStatus === 'running' ? 'stop' : 'play'}"></i>`;
                    startStopBtn.title = `${newStatus === 'running' ? 'Stop' : 'Start'} pipeline`;
                    startStopBtn.disabled = false;
                    startStopBtn.onclick = () => newStatus === 'running' ? stopPipeline(pipelineId) : startPipeline(pipelineId);
                }
            }
            
            // Preview is now handled by toggle switch, not button
        }
        
        // Remove preview hover functionality when stopped
        if (newStatus !== 'running') {
            rowElement.className = '';
            rowElement.onmouseenter = null;
            rowElement.onmouseleave = null;
            
            // Reset list view metrics when pipeline stops (but not during starting)
            if (newStatus !== 'starting') {
                const listFpsElement = rowElement.querySelector(`#list-fps-${pipelineId}`);
                const listLatencyElement = rowElement.querySelector(`#list-latency-${pipelineId}`);
                const listUptimeElement = rowElement.querySelector(`#list-uptime-${pipelineId}`);
                
                if (listFpsElement) listFpsElement.textContent = '0.0';
                if (listLatencyElement) listLatencyElement.textContent = '0ms';
                if (listUptimeElement) listUptimeElement.textContent = '0s';
            }
        }
    }
    
    // Load thumbnail when pipeline is stopped (for card view)
    if (newStatus === 'stopped' && currentViewMode === 'card') {
        console.log(`Pipeline ${pipelineId} stopped, scheduling thumbnail load...`);
        setTimeout(() => {
            console.log(`Loading thumbnail for stopped pipeline ${pipelineId} from updateSinglePipelineState`);
            forceShowThumbnailForStopped(pipelineId);
        }, 200); // Shorter delay since this runs after UI state updates
    }
    
    // Update thumbnail container status attribute
    const thumbnailContainer = document.getElementById(`thumbnail-${pipelineId}`);
    if (thumbnailContainer) {
        thumbnailContainer.setAttribute('data-pipeline-status', newStatus);
    }
    
    // Update hover overlays based on new status
    updateHoverOverlays(pipelineId, newStatus);
}

// Update hover overlays when pipeline status changes
function updateHoverOverlays(pipelineId, status) {
    // Update thumbnail hover overlay
    const thumbnailContainer = document.getElementById(`thumbnail-${pipelineId}`);
    if (thumbnailContainer) {
        // Remove existing overlays
        const existingHoverOverlay = thumbnailContainer.querySelector('.preview-hover-overlay');
        const existingMessageOverlay = thumbnailContainer.querySelector('.preview-message-overlay');
        if (existingHoverOverlay) existingHoverOverlay.remove();
        if (existingMessageOverlay) existingMessageOverlay.remove();
        
        // Add appropriate overlay based on status
        if (status === 'running') {
            const overlay = document.createElement('div');
            overlay.className = 'preview-hover-overlay';
            overlay.onclick = () => togglePreview(pipelineId);
            overlay.innerHTML = `
                <div class="preview-play-button">
                    <i class="fas fa-play"></i>
                </div>
            `;
            thumbnailContainer.appendChild(overlay);
        } else if (status === 'starting') {
            const overlay = document.createElement('div');
            overlay.className = 'preview-message-overlay';
            overlay.innerHTML = `
                <div class="preview-message-text">
                    <i class="fas fa-spinner fa-spin me-2"></i>Starting pipeline...
                </div>
            `;
            thumbnailContainer.appendChild(overlay);
        } else if (status === 'stopped') {
            const overlay = document.createElement('div');
            overlay.className = 'preview-message-overlay';
            overlay.innerHTML = `
                <div class="preview-message-text">
                    Start pipeline to view live preview
                </div>
            `;
            thumbnailContainer.appendChild(overlay);
        } else if (status === 'error') {
            const overlay = document.createElement('div');
            overlay.className = 'preview-message-overlay';
            overlay.innerHTML = `
                <div class="preview-message-text">
                    Pipeline error - restart to view preview
                </div>
            `;
            thumbnailContainer.appendChild(overlay);
        }
    }
    
    // Update default placeholder hover overlay
    const previewElement = document.getElementById(`preview-${pipelineId}`);
    const placeholderContainer = previewElement ? previewElement.parentElement.querySelector('.preview-placeholder') : null;
    if (placeholderContainer) {
        // Remove existing overlays
        const existingHoverOverlay = placeholderContainer.querySelector('.preview-hover-overlay');
        const existingMessageOverlay = placeholderContainer.querySelector('.preview-message-overlay');
        if (existingHoverOverlay) existingHoverOverlay.remove();
        if (existingMessageOverlay) existingMessageOverlay.remove();
        
        // Add appropriate overlay based on status
        if (status === 'running') {
            const overlay = document.createElement('div');
            overlay.className = 'preview-hover-overlay';
            overlay.onclick = () => togglePreview(pipelineId);
            overlay.innerHTML = `
                <div class="preview-play-button">
                    <i class="fas fa-play"></i>
                </div>
            `;
            placeholderContainer.appendChild(overlay);
        } else if (status === 'starting') {
            const overlay = document.createElement('div');
            overlay.className = 'preview-message-overlay';
            overlay.innerHTML = `
                <div class="preview-message-text">
                    <i class="fas fa-spinner fa-spin me-2"></i>Starting pipeline...
                </div>
            `;
            placeholderContainer.appendChild(overlay);
        } else if (status === 'stopped') {
            const overlay = document.createElement('div');
            overlay.className = 'preview-message-overlay';
            overlay.innerHTML = `
                <div class="preview-message-text">
                    Start pipeline to view live preview
                </div>
            `;
            placeholderContainer.appendChild(overlay);
        } else if (status === 'error') {
            const overlay = document.createElement('div');
            overlay.className = 'preview-message-overlay';
            overlay.innerHTML = `
                <div class="preview-message-text">
                    Pipeline error - restart to view preview
                </div>
            `;
            placeholderContainer.appendChild(overlay);
        }
    }
    
    // Update live preview hover overlay (pause button)
    const previewContainer = document.getElementById(`preview-${pipelineId}`);
    if (previewContainer) {
        // Remove existing overlay
        const existingOverlay = previewContainer.querySelector('.preview-hover-overlay');
        if (existingOverlay) {
            existingOverlay.remove();
        }
        
        // Add overlay only if pipeline is running (no message overlay for live preview since it's not visible when stopped)
        if (status === 'running') {
            const overlay = document.createElement('div');
            overlay.className = 'preview-hover-overlay';
            overlay.onclick = () => togglePreview(pipelineId);
            overlay.innerHTML = `
                <div class="preview-play-button">
                    <i class="fas fa-pause"></i>
                </div>
            `;
            previewContainer.appendChild(overlay);
        }
    }
}

// Update real-time metrics for running pipelines
async function updatePipelineMetrics() {
    try {
        // Use the lightweight metrics endpoint instead of full pipeline data
        const response = await fetch('/api/pipelines/metrics');
        const data = await response.json();
        
        if (response.ok) {
            // Statistics are now handled on the telemetry page
            
            // Update individual pipeline metrics for running pipelines only
            if (data.running_pipelines) {
                Object.entries(data.running_pipelines).forEach(([pipelineId, metrics]) => {
                    // Update card view metrics
                    const fpsElement = document.getElementById(`fps-${pipelineId}`);
                    const latencyElement = document.getElementById(`latency-${pipelineId}`);
                    const framesElement = document.getElementById(`frames-${pipelineId}`);
                    const uptimeElement = document.getElementById(`uptime-${pipelineId}`);
                    
                    if (fpsElement) {
                        fpsElement.textContent = metrics.fps || '0.0';
                    }
                    if (latencyElement) {
                        // Use actual latency from metrics
                        const latency = metrics.latency_ms || 0;
                        latencyElement.textContent = Math.round(latency) + 'ms';
                    }
                    if (framesElement) {
                        const frames = metrics.frame_count || 0;
                        framesElement.textContent = frames > 1000 ? 
                            (frames / 1000).toFixed(1) + 'K' : frames.toString();
                    }
                    if (uptimeElement) {
                        uptimeElement.textContent = metrics.uptime || '0s';
                    }
                    
                    // Update list view metrics
                    const listFpsElement = document.getElementById(`list-fps-${pipelineId}`);
                    const listLatencyElement = document.getElementById(`list-latency-${pipelineId}`);
                    const listUptimeElement = document.getElementById(`list-uptime-${pipelineId}`);
                    if (listFpsElement) {
                        listFpsElement.textContent = metrics.fps || '0.0';
                    }
                    if (listLatencyElement) {
                        const latency = metrics.latency_ms || 0;
                        listLatencyElement.textContent = Math.round(latency) + 'ms';
                    }
                    if (listUptimeElement) {
                        listUptimeElement.textContent = metrics.uptime || '0s';
                    }
                    
                    // Also update publisher states for running pipelines
                    updatePublisherStates(pipelineId);
                });
            }
            
            // Reset metrics for stopped pipelines to zero
            allPipelines.forEach(pipeline => {
                if (pipeline.status !== 'running') {
                    const fpsElement = document.getElementById(`fps-${pipeline.id}`);
                    const latencyElement = document.getElementById(`latency-${pipeline.id}`);
                    const framesElement = document.getElementById(`frames-${pipeline.id}`);
                    const listFpsElement = document.getElementById(`list-fps-${pipeline.id}`);
                    const listLatencyElement = document.getElementById(`list-latency-${pipeline.id}`);
                    
                    if (fpsElement) fpsElement.textContent = '0.0';
                    if (latencyElement) latencyElement.textContent = '0ms';
                    if (framesElement) framesElement.textContent = '0';
                    if (listFpsElement) listFpsElement.textContent = '0.0';
                    if (listLatencyElement) listLatencyElement.textContent = '0ms';
                }
            });
        }
    } catch (error) {
        console.warn('Failed to update pipeline metrics:', error);
    }
}

// Update publisher states for a specific pipeline
async function updatePublisherStates(pipelineId) {
    try {
        const response = await fetch(`/api/pipeline/${pipelineId}/publishers/status`);
        const data = await response.json();
        
        if (response.ok && data.publishers) {
            // Update local pipeline data with enhanced states
            const pipeline = allPipelines.find(p => p.id === pipelineId);
            if (pipeline && pipeline.destinations) {
                Object.entries(data.publishers).forEach(([publisherId, publisherState]) => {
                    const destination = pipeline.destinations.find(dest => dest.id === publisherId);
                    if (destination) {
                        destination.enabled = publisherState.enabled;
                        destination.failure_count = publisherState.failure_count || 0;
                        destination.auto_disabled = publisherState.auto_disabled || false;
                        destination.last_error = publisherState.last_error;
                        destination.is_paused = publisherState.is_paused || false;
                        destination.frame_count = publisherState.frame_count || 0;
                        destination.max_frames = publisherState.max_frames;
                    }
                });
                
                // Update the UI for this specific pipeline
                updatePipelinePublisherUI(pipelineId, pipeline);
            }
        }
    } catch (error) {
        console.warn(`Failed to update publisher states for pipeline ${pipelineId}:`, error);
    }
}

// Update publisher UI for a specific pipeline
function updatePipelinePublisherUI(pipelineId, pipeline) {
    const cardElement = document.querySelector(`[data-pipeline-id="${pipelineId}"]`);
    if (!cardElement) return;
    
    // Find and update publisher list
    const publisherList = cardElement.querySelector('.publisher-list');
    if (publisherList && pipeline.destinations) {
        // Re-render publisher list with updated states
        publisherList.innerHTML = pipeline.destinations.map(dest => {
            let statusText = 'Enabled';
            let statusClass = 'text-success';
            let statusIcon = '';
            let toggleEnabled = true;
            let toggleChecked = dest.enabled !== false;
            
            // Determine status based on current state
            if (dest.auto_disabled) {
                statusText = 'Auto-Disabled';
                statusClass = 'text-danger';
                statusIcon = '<i class="fas fa-exclamation-triangle me-1"></i>';
                toggleEnabled = false;
                toggleChecked = false;
            } else if (dest.is_paused) {
                // Paused state - toggle OFF but remains enabled (clickable)
                statusText = `Paused (${dest.frame_count}/${dest.max_frames} frames)`;
                statusClass = 'text-warning';
                statusIcon = '<i class="fas fa-pause-circle me-1"></i>';
                toggleEnabled = true;
                toggleChecked = false;  // Turn toggle OFF when paused
            } else if (dest.enabled === false) {
                statusText = 'Disabled';
                statusClass = 'text-muted';
                toggleEnabled = true;
                toggleChecked = false;
            } else if (dest.failure_count && dest.failure_count > 0) {
                statusText = `Error (${dest.failure_count} failures)`;
                statusClass = 'text-warning';
                statusIcon = '<i class="fas fa-exclamation-circle me-1"></i>';
                toggleEnabled = true;
                toggleChecked = true;
            } else if (dest.frame_count && dest.max_frames) {
                // Show progress when frames are being tracked
                statusText = `Active (${dest.frame_count}/${dest.max_frames} frames)`;
                statusClass = 'text-success';
                toggleChecked = true;
            }
            
            return `
            <div class="d-flex justify-content-between align-items-center py-1 px-2 mb-1 rounded" style="background-color: rgba(0,0,0,0.05);">
                <div class="d-flex align-items-center flex-grow-1">
                    <span class="badge bg-secondary me-2">${dest.type.toUpperCase()}</span>
                    <div class="d-flex flex-column">
                        <small class="${statusClass}">${statusIcon}${statusText}</small>
                        ${dest.last_error ? `<small class="text-danger" style="font-size: 10px;" title="${dest.last_error}">Error: ${dest.last_error.length > 30 ? dest.last_error.substring(0, 30) + '...' : dest.last_error}</small>` : ''}
                        ${dest.is_paused ? `<small class="text-info" style="font-size: 10px;"><i class="fas fa-info-circle me-1"></i>Toggle to resume</small>` : ''}
                    </div>
                </div>
                <div class="d-flex align-items-center gap-1">
                    <label class="destination-toggle-small ${dest.is_paused ? 'paused' : ''} ms-1">
                        <input type="checkbox" 
                               ${toggleChecked ? 'checked' : ''}
                               ${pipeline.status !== 'running' || !toggleEnabled ? 'disabled' : ''}
                               onchange="togglePublisher('${pipeline.id}', '${dest.id}', this.checked)">
                        <span class="destination-slider-small"></span>
                    </label>
                </div>
            </div>
            `;
        }).join('');
    }
}

// Update statistics from local pipeline data (without API call)
function updateStatisticsFromLocal() {
    // Statistics cards have been moved to telemetry page
    // This function is kept for any future local statistics needs
}

// Quick filter functionality
let activeQuickFilters = new Set();

function toggleQuickFilter(filterTerm) {
    const searchInput = document.getElementById('searchPipelines');
    
    console.log('Toggle quick filter called with:', filterTerm);
    
    // Check if this filter is currently active
    const isCurrentlyActive = activeQuickFilters.has(filterTerm);
    
    console.log('Is currently active:', isCurrentlyActive);
    console.log('Current active filters before:', Array.from(activeQuickFilters));
    
    if (isCurrentlyActive) {
        // Remove the filter
        activeQuickFilters.delete(filterTerm);
    } else {
        // Add the filter
        activeQuickFilters.add(filterTerm);
        
        // Handle status filters (exclusive within category)
        if (filterTerm === 'running' || filterTerm === 'stopped' || filterTerm === 'error') {
            // Remove other status filters
            activeQuickFilters.delete('running');
            activeQuickFilters.delete('stopped');
            activeQuickFilters.delete('error');
            activeQuickFilters.add(filterTerm);
        }
        // Handle engine filters (exclusive within category)
        else if (availableEngineTypes.some(e => e.type === filterTerm)) {
            // Remove all engine filters
            availableEngineTypes.forEach(e => activeQuickFilters.delete(e.type));
            activeQuickFilters.add(filterTerm);
        }
        // Handle source type filters (exclusive within category)
        else if (filterTerm === 'webcam' || filterTerm === 'rtsp' || filterTerm === 'ip_camera') {
            // Remove other source type filters from active set
            activeQuickFilters.delete('webcam');
            activeQuickFilters.delete('rtsp');
            activeQuickFilters.delete('ip_camera');
            activeQuickFilters.add(filterTerm);
        }
        // Handle destination type filters (exclusive within category)
        else if (filterTerm === 'mqtt' || filterTerm === 'webhook') {
            // Remove other destination filters from active set
            activeQuickFilters.delete('mqtt');
            activeQuickFilters.delete('webhook');
            activeQuickFilters.add(filterTerm);
            console.log('Added destination filter:', filterTerm);
        }
        // Handle hardware type filters (exclusive within category)
        else if (filterTerm === 'cpu' || filterTerm === 'gpu' || filterTerm === 'npu') {
            // Remove other hardware filters from active set
            activeQuickFilters.delete('cpu');
            activeQuickFilters.delete('gpu');
            activeQuickFilters.delete('npu');
            activeQuickFilters.add(filterTerm);
            console.log('Added hardware filter:', filterTerm);
        }
    }
    
    console.log('Active filters after:', Array.from(activeQuickFilters));
    
    // Update badge visual states
    updateQuickFilterBadges();
    
    // Apply filters
    filterPipelines();
}

function updateQuickFilterBadges() {
    const badges = document.querySelectorAll('.quick-search-badge');
    
    badges.forEach(badge => {
        // Try to get filter term from data attribute first (for dynamically created badges)
        let filterTerm = badge.getAttribute('data-filter-term');
        
        // If no data attribute, try to extract from onclick attribute (for static badges)
        if (!filterTerm) {
            filterTerm = badge.onclick.toString().match(/toggleQuickFilter\('([^']+)'\)/)?.[1];
        }
        
        if (filterTerm && activeQuickFilters.has(filterTerm)) {
            badge.classList.add('active');
        } else {
            badge.classList.remove('active');
        }
    });
}

// Filter pipelines based on search and filters
function filterPipelines() {
    console.log('=== FILTER PIPELINES CALLED ===');
    console.log('Active previews before filtering:', Array.from(activePreviews));
    
    // Save current preview states before filtering
    const savedPreviews = new Set(activePreviews);
    
    const searchTerm = document.getElementById('searchPipelines').value.toLowerCase();
    
    // Get active filters from the quick filter set
    const statusFilters = ['running', 'starting', 'stopped', 'error'].filter(status => activeQuickFilters.has(status));
    const engineFilters = availableEngineTypes.map(e => e.type).filter(engine => activeQuickFilters.has(engine));
    const sourceFilters = ['webcam', 'rtsp', 'ip_camera'].filter(source => activeQuickFilters.has(source));
    const destinationFilters = ['mqtt', 'webhook'].filter(dest => activeQuickFilters.has(dest));
    const hardwareFilters = ['cpu', 'gpu', 'npu'].filter(hardware => activeQuickFilters.has(hardware));
    
    console.log('Active filters:', {
        status: statusFilters,
        engine: engineFilters,
        source: sourceFilters,
        destination: destinationFilters,
        hardware: hardwareFilters
    });
    
    // Add search term to source filters if it matches common filter terms
    if (searchTerm && ['webcam', 'rtsp', 'ip_camera', 'realsense', 'file'].includes(searchTerm)) {
        if (!sourceFilters.includes(searchTerm)) {
            activeQuickFilters.add(searchTerm);
        }
    }
    
    filteredPipelines = allPipelines.filter(pipeline => {
        const matchesSearch = !searchTerm || 
            pipeline.name.toLowerCase().includes(searchTerm) ||
            (pipeline.description || '').toLowerCase().includes(searchTerm) ||
            // Search in status
            (pipeline.status || '').toLowerCase().includes(searchTerm) ||
            // Search in frame source type
            (pipeline.frame_source?.capture_type || pipeline.frame_source?.type || '').toLowerCase().includes(searchTerm) ||
            // Search in model information
            (pipeline.model?.engine_type || '').toLowerCase().includes(searchTerm) ||
            (pipeline.model?.id || '').toLowerCase().includes(searchTerm) ||
            // Search in device information
            (pipeline.model?.device || '').toLowerCase().includes(searchTerm) ||
            // Search in result destinations
            (pipeline.result_destinations && pipeline.result_destinations.some(dest => 
                (dest.type || '').toLowerCase().includes(searchTerm) ||
                (dest.destination_type || '').toLowerCase().includes(searchTerm) ||
                (dest.config?.host || '').toLowerCase().includes(searchTerm) ||
                (dest.config?.topic || '').toLowerCase().includes(searchTerm) ||
                (dest.config?.url || '').toLowerCase().includes(searchTerm)
            )) ||
            // Also search in destinations array if it exists
            (pipeline.destinations && pipeline.destinations.some(dest => 
                (dest.type || '').toLowerCase().includes(searchTerm) ||
                (dest.destination_type || '').toLowerCase().includes(searchTerm)
            ));
        
        const matchesStatus = statusFilters.length === 0 || statusFilters.includes(pipeline.status);
        
        const matchesEngine = engineFilters.length === 0 || 
            (pipeline.model && engineFilters.includes(pipeline.model.engine_type));
        
        const matchesSource = sourceFilters.length === 0 || 
            sourceFilters.some(source => 
                (pipeline.frame_source?.capture_type || pipeline.frame_source?.type || '').toLowerCase().includes(source)
            );
        
        const matchesDestination = destinationFilters.length === 0 || 
            (pipeline.result_destinations && pipeline.result_destinations.some(dest => {
                return destinationFilters.includes(dest.type?.toLowerCase()) || 
                       destinationFilters.includes(dest.destination_type?.toLowerCase());
            })) ||
            (pipeline.destinations && pipeline.destinations.some(dest => {
                return destinationFilters.includes(dest.type?.toLowerCase()) || 
                       destinationFilters.includes(dest.destination_type?.toLowerCase());
            }));
        
        const matchesHardware = hardwareFilters.length === 0 || 
            (pipeline.model && pipeline.model.device && 
             hardwareFilters.some(hardware => pipeline.model.device.toLowerCase().includes(hardware)));
        
        return matchesSearch && matchesStatus && matchesEngine && matchesSource && matchesDestination && matchesHardware;
    });
    
    console.log(`Filtered ${filteredPipelines.length} pipelines from ${allPipelines.length} total`);
    
    // Update quick filter badge visual states
    updateQuickFilterBadges();
    
    // Update individual pipeline cards/rows without full re-render to preserve previews
    filteredPipelines.forEach(pipeline => {
        updatePipelineUI(pipeline, savedPreviews);
    });
    
    // Remove pipelines that no longer exist or match filters
    const currentPipelineIds = new Set(filteredPipelines.map(p => p.id));
    const previewsToRemove = [];
    activePreviews.forEach(pipelineId => {
        if (!currentPipelineIds.has(pipelineId)) {
            previewsToRemove.push(pipelineId);
        }
    });
    
    console.log('Previews to remove (filtered out):', previewsToRemove);
    
    // Clean up previews for removed/filtered pipelines
    previewsToRemove.forEach(pipelineId => {
        console.log(`Stopping preview for filtered-out pipeline: ${pipelineId}`);
        stopPreviewStream(pipelineId);
        activePreviews.delete(pipelineId);
    });
    
    // Check if we need a full render (new pipelines added or pipelines removed from view)
    const existingPipelineIds = new Set(Array.from(document.querySelectorAll('[data-pipeline-id]')).map(el => el.getAttribute('data-pipeline-id')));
    const needsFullRender = filteredPipelines.some(p => !existingPipelineIds.has(p.id)) || 
                            Array.from(existingPipelineIds).some(id => !currentPipelineIds.has(id));
    
    console.log(`Filter check - needsFullRender: ${needsFullRender}, filtered: ${filteredPipelines.length}, existing: ${existingPipelineIds.size}`);
    
    // Always render when filtering to ensure cards are shown/hidden correctly
    if (currentViewMode === 'card') {
        renderCardView();
    } else {
        renderListView();
    }
    
    // Restore previews after render - ONLY for pipelines that still match filters and are running
    if (needsFullRender) {
        // Use a delay to ensure DOM is fully rendered and stabilized
        setTimeout(() => {
            console.log('Restoring previews after full render');
            savedPreviews.forEach(pipelineId => {
                if (currentPipelineIds.has(pipelineId)) {
                    const pipeline = filteredPipelines.find(p => p.id === pipelineId);
                    if (pipeline && pipeline.status === 'running') {
                        console.log(`Restoring preview for ${pipelineId}`);
                        // Re-add to activePreviews to maintain the state
                        if (!activePreviews.has(pipelineId)) {
                            activePreviews.add(pipelineId);
                        }
                        // startPreviewStream now checks if stream is already active before restarting
                        startPreviewStream(pipelineId);
                        updatePreviewContainerVisibility(pipelineId, true);
                    } else {
                        console.log(`NOT restoring preview for ${pipelineId} - status: ${pipeline?.status}`);
                    }
                }
            });
        }, 150); // Slightly longer delay for stability
    } else {
        console.log('Partial update - no full render needed');
        // For partial updates, restore previews for newly visible pipelines ONLY
        savedPreviews.forEach(pipelineId => {
            if (currentPipelineIds.has(pipelineId)) {
                const pipeline = filteredPipelines.find(p => p.id === pipelineId);
                if (pipeline && pipeline.status === 'running') {
                    // Ensure preview is in active set
                    if (!activePreviews.has(pipelineId)) {
                        console.log(`Re-adding preview to active set: ${pipelineId}`);
                        activePreviews.add(pipelineId);
                        // Only start stream if it's not already running
                        startPreviewStream(pipelineId);
                        updatePreviewContainerVisibility(pipelineId, true);
                    } else {
                        console.log(`Preview already active for ${pipelineId}`);
                    }
                    
                    // For list view, also restore hover functionality
                    if (currentViewMode === 'list') {
                        const rowElement = document.querySelector(`tr[data-pipeline-id="${pipelineId}"]`);
                        if (rowElement) {
                            rowElement.className = 'preview-enabled';
                            rowElement.onmouseenter = () => showListPreview(pipelineId);
                            rowElement.onmouseleave = () => hideListPreview();
                        }
                    }
                }
            }
        });
    }
    
    // Show empty state if needed
    if (filteredPipelines.length === 0) {
        document.getElementById('pipelinesContainer').style.display = 'none';
        document.getElementById('emptyState').style.display = 'block';
    } else {
        document.getElementById('pipelinesContainer').style.display = 'block';
        document.getElementById('emptyState').style.display = 'none';
    }
}

// Clear search function
function clearSearch() {
    const searchInput = document.getElementById('searchPipelines');
    searchInput.value = '';
    filterPipelines();
}

// Toggle between card and list view
function toggleViewMode(mode) {
    // Clean up any active list preview when switching away from list view
    if (currentViewMode === 'list' && mode !== 'list') {
        hideListPreview();
    }
    
    currentViewMode = mode;
    
    // Save the view mode preference to localStorage
    localStorage.setItem('pipelineViewMode', mode);
    
    const cardContainer = document.getElementById('cardViewContainer');
    const listContainer = document.getElementById('listViewContainer');
    
    if (mode === 'card') {
        listContainer.style.display = 'none';
        cardContainer.style.display = '';
        
        // Use requestAnimationFrame to ensure proper layout timing
        requestAnimationFrame(() => {
            renderPipelines();
        });
    } else {
        cardContainer.style.display = 'none';
        listContainer.style.display = 'block';
        renderPipelines();
    }
}

// Render pipelines in current view mode
function renderPipelines() {
    if (filteredPipelines.length === 0) {
        document.getElementById('pipelinesContainer').style.display = 'none';
        document.getElementById('emptyState').style.display = 'block';
        return;
    }
    
    document.getElementById('pipelinesContainer').style.display = 'block';
    document.getElementById('emptyState').style.display = 'none';
    
    if (currentViewMode === 'card') {
        renderCardView();
    } else {
        renderListView();
    }
}

// Render card view
function renderCardView() {
    const container = document.getElementById('cardViewContainer');
    
    // Check if we can do a smart update (hiding/showing cards) instead of full re-render
    const existingCards = container.querySelectorAll('[data-pipeline-id]');
    const existingIds = new Set(Array.from(existingCards).map(card => card.getAttribute('data-pipeline-id')));
    const filteredIds = new Set(filteredPipelines.map(p => p.id));
    const allPipelineIds = new Set(allPipelines.map(p => p.id));
    
    // We can do a smart update if:
    // 1. All existing cards are in the allPipelines list (no orphaned cards)
    // 2. All filtered pipelines already have cards in the DOM
    // 3. We're just showing/hiding, not adding new pipelines
    const canSmartUpdate = existingCards.length > 0 &&
                          Array.from(existingIds).every(id => allPipelineIds.has(id)) &&
                          filteredPipelines.every(p => existingIds.has(p.id));
    
    if (canSmartUpdate) {
        console.log('Smart update: showing/hiding existing cards');
        console.log(`Showing ${filteredIds.size} cards, hiding ${existingIds.size - filteredIds.size} cards`);
        
        // Show/hide cards based on filter
        existingCards.forEach(card => {
            const pipelineId = card.getAttribute('data-pipeline-id');
            if (filteredIds.has(pipelineId)) {
                // Show this card
                card.style.display = '';
                card.classList.remove('d-none');
                // Update the card's data in case it changed
                const pipeline = filteredPipelines.find(p => p.id === pipelineId);
                if (pipeline) {
                    updatePipelineUI(pipeline, activePreviews);
                }
            } else {
                // Hide this card
                card.style.display = 'none';
                card.classList.add('d-none');
            }
        });
        
        // Load thumbnails for newly visible stopped pipelines
        filteredPipelines.forEach(pipeline => {
            if (!activePreviews.has(pipeline.id) && pipeline.status === 'stopped') {
                setTimeout(() => loadThumbnail(pipeline.id), 100);
            }
        });
        
        return; // Skip full re-render
    }
    
    console.log('Full re-render of card view');
    
    const html = filteredPipelines.map(pipeline => {
        const statusColor = getStatusColor(pipeline.status);
        const sourceInfo = getSourceInfo(pipeline);
        const modelInfo = getModelInfo(pipeline);
        const deviceInfo = getDeviceInfo(pipeline);
        const previewId = `preview-${pipeline.id}`;
        const isPreviewActive = activePreviews.has(pipeline.id);
        
        return `
            <div class="col-xl-4 col-lg-6 col-md-6 col-sm-12 mb-3" data-pipeline-id="${pipeline.id}">
                <div class="card h-100 pipeline-card">
                    <div class="card-header d-flex justify-content-between align-items-center py-2">
                        <div>
                            <h6 class="mb-1">${pipeline.name}</h6>
                            <div class="d-flex gap-1">
                                <span class="badge bg-${statusColor} badge-sm">${capitalizeStatus(pipeline.status)}</span>
                                <span class="badge ${(pipeline.status === 'running' || pipeline.status === 'starting') ? ((pipeline.inference_enabled === true || pipeline.inference_enabled === undefined) ? 'bg-info' : 'bg-secondary') : 'bg-secondary'} badge-sm" style="display: ${(pipeline.status === 'running' || pipeline.status === 'starting') ? '' : 'none'};">
                                    <i class="fas fa-brain me-1"></i>
                                    ${(pipeline.status === 'running' || pipeline.status === 'starting') ? ((pipeline.inference_enabled === true || pipeline.inference_enabled === undefined) ? 'Inference ON' : 'Inference OFF') : 'Inference OFF'}
                                </span>
                            </div>
                        </div>
                        <div class="dropdown">
                            <button class="btn btn-sm btn-outline-secondary" type="button" data-bs-toggle="dropdown">
                                <i class="fas fa-ellipsis-v"></i>
                            </button>
                            <ul class="dropdown-menu dropdown-menu-end">
                                <li><a class="dropdown-item" href="#" onclick="showPipelineDetails('${pipeline.id}')">
                                    <i class="fas fa-info-circle me-2"></i>Details
                                </a></li>
                                <li><a class="dropdown-item" href="#" onclick="editPipeline('${pipeline.id}')">
                                    <i class="fas fa-edit me-2"></i>Edit
                                </a></li>
                                <li><a class="dropdown-item" href="#" onclick="duplicatePipeline('${pipeline.id}')">
                                    <i class="fas fa-copy me-2"></i>Duplicate
                                </a></li>
                                <li><a class="dropdown-item" href="#" onclick="exportPipeline('${pipeline.id}')">
                                    <i class="fas fa-download me-2"></i>Export
                                </a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item text-danger" href="#" onclick="deletePipeline('${pipeline.id}')">
                                    <i class="fas fa-trash me-2"></i>Delete
                                </a></li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="card-body p-3">
                        <!-- Pipeline Info Badges -->
                        <div class="pipeline-info-badges mb-3">
                            <span class="badge bg-secondary badge-sm" title="Frame Source">
                                <i class="fas fa-video me-1"></i>${sourceInfo.display}
                            </span>
                            <span class="badge bg-secondary badge-sm" title="Inference Engine">
                                <i class="fas fa-brain me-1"></i>${modelInfo.engineBadge}
                            </span>
                            <span class="badge bg-secondary badge-sm" title="Model">
                                <i class="fas fa-cube me-1"></i>${modelInfo.modelBadge}
                            </span>
                            <span class="badge bg-secondary badge-sm" title="Processing Device">
                                <i class="fas fa-microchip me-1"></i>${deviceInfo.display}
                            </span>
                            <!-- Destination badges commented out - redundant with publisher toggles at bottom
                            ${pipeline.destinations && pipeline.destinations.length > 0 ? 
                                pipeline.destinations.map(dest => 
                                    `<span class="badge bg-secondary badge-sm" title="Result Destination">
                                        <i class="fas fa-arrow-right me-1"></i>${dest.type.toUpperCase()}
                                    </span>`
                                ).join('') 
                                : '<span class="badge bg-secondary badge-sm" title="No Destinations"><i class="fas fa-ban me-1"></i>None</span>'
                            }
                            -->
                        </div>
                        
                        <!-- Live Preview Area -->
                        <div class="preview-container mb-3" style="height: 360px; border: 1px dashed #dee2e6; border-radius: 4px; position: relative; overflow: hidden; background-color: #1a1a1a;">
                            <div id="${previewId}" class="preview-content position-absolute w-100 h-100" style="display: ${isPreviewActive ? 'block' : 'none'}; z-index: 2;">
                                <img class="preview-stream w-100 h-100" style="height: 360px; object-fit: contain; border-radius: 4px; background-color: #1a1a1a;" />
                                <div class="preview-overlay position-absolute top-0 end-0 p-1">
                                    <button class="btn btn-sm btn-outline-light" onclick="openFullPreview('${pipeline.id}', '${pipeline.name}')" title="Full Screen">
                                        <i class="fas fa-expand"></i>
                                    </button>
                                </div>
                                <!-- Pause overlay for active streams - only show when pipeline is running -->
                                ${pipeline.status === 'running' ? `
                                <div class="preview-hover-overlay" onclick="togglePreview('${pipeline.id}')">
                                    <div class="preview-play-button">
                                        <i class="fas fa-pause"></i>
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                            <!-- Thumbnail fallback placeholder -->
                            <div id="thumbnail-${pipeline.id}" class="thumbnail-placeholder position-absolute w-100 h-100" 
                                 data-pipeline-status="${pipeline.status}"
                                 style="display: none; z-index: 1;">
                                <img class="thumbnail-image w-100 h-100" style="object-fit: contain; border-radius: 4px;" />
                                <div class="thumbnail-overlay position-absolute top-0 end-0 p-1">
                                    <span class="badge bg-dark bg-opacity-75">
                                        <i class="fas fa-image me-1"></i>Thumbnail
                                    </span>
                                </div>
                                ${pipeline.status === 'running' ? `
                                <div class="preview-hover-overlay" onclick="togglePreview('${pipeline.id}')">
                                    <div class="preview-play-button">
                                        <i class="fas fa-play"></i>
                                    </div>
                                </div>
                                ` : pipeline.status === 'stopped' ? `
                                <div class="preview-message-overlay">
                                    <div class="preview-message-text">
                                        Start pipeline to view live preview
                                    </div>
                                </div>
                                ` : pipeline.status === 'error' ? `
                                <div class="preview-message-overlay">
                                    <div class="preview-message-text">
                                        Pipeline error - restart to view preview
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                            <!-- Default placeholder (no thumbnail available) -->
                            <div class="preview-placeholder position-absolute w-100 h-100" 
                                 style="display: ${isPreviewActive ? 'none' : (pipeline.status === 'stopped' || pipeline.status === 'error' ? 'none' : 'flex')}; z-index: 1; background-color: #1a1a1a; align-items: center; justify-content: center;" 
                                 ${pipeline.status === 'running' ? `onclick="togglePreview('${pipeline.id}')"` : (pipeline.status === 'stopped' || pipeline.status === 'error') ? `onclick="startPipeline('${pipeline.id}')"` : ''}>
                                <div class="text-center text-muted">
                                    <i class="fas fa-video fa-2x mb-2"></i>
                                    <div>Live Preview</div>
                                </div>
                                ${pipeline.status === 'running' ? `
                                <div class="preview-hover-overlay" onclick="togglePreview('${pipeline.id}')">
                                    <div class="preview-play-button">
                                        <i class="fas fa-play"></i>
                                    </div>
                                </div>
                                ` : pipeline.status === 'starting' ? `
                                <div class="preview-message-overlay">
                                    <div class="preview-message-text">
                                        <i class="fas fa-spinner fa-spin me-2"></i>Starting pipeline...
                                    </div>
                                </div>
                                ` : pipeline.status === 'stopped' ? `
                                <div class="preview-message-overlay">
                                    <div class="preview-message-text">
                                        Start pipeline to view live preview
                                    </div>
                                </div>
                                ` : pipeline.status === 'error' ? `
                                <div class="preview-message-overlay">
                                    <div class="preview-message-text">
                                        Pipeline error - restart to view preview
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                        </div>
                        
                        <!-- Performance Metrics (always visible) -->
                        <div class="row g-2 mb-1">
                            <div class="col-3 text-center">
                                <div class="text-info mb-0" id="fps-${pipeline.id}">${pipeline.status === 'running' ? ((pipeline.stats && pipeline.stats.fps !== undefined) ? pipeline.stats.fps : (pipeline.fps !== undefined) ? pipeline.fps : '0.0') : '0.0'}</div>
                                <small class="text-muted">FPS</small>
                            </div>
                            <div class="col-3 text-center">
                                <div class="mb-0" id="latency-${pipeline.id}" style="color: #ffc107;">
                                    ${pipeline.status === 'running' ? ((pipeline.stats && pipeline.stats.latency_ms !== undefined) ? pipeline.stats.latency_ms + 'ms' : (pipeline.latency_ms !== undefined) ? pipeline.latency_ms + 'ms' : '0ms') : '0ms'}
                                </div>
                                <small class="text-muted">Latency</small>
                            </div>
                            <div class="col-3 text-center">
                                <div class="text-success mb-0" id="uptime-${pipeline.id}">${pipeline.status === 'running' ? (pipeline.uptime || '0s') : '0s'}</div>
                                <small class="text-muted">Uptime</small>
                            </div>
                            <div class="col-3 text-center">
                                <div class="text-warning mb-0" id="frames-${pipeline.id}">${pipeline.status === 'running' ? ((pipeline.stats && pipeline.stats.frame_count !== undefined) ? (pipeline.stats.frame_count > 1000 ? (pipeline.stats.frame_count / 1000).toFixed(1) + 'K' : pipeline.stats.frame_count) : (pipeline.frame_count !== undefined) ? (pipeline.frame_count > 1000 ? (pipeline.frame_count / 1000).toFixed(1) + 'K' : pipeline.frame_count) : '0') : '0'}</div>
                                <small class="text-muted">Frames</small>
                            </div>
                        </div>
                        
                        <!-- Publisher Controls (only show if pipeline has destinations) -->
                        ${pipeline.destinations && pipeline.destinations.length > 0 ? `
                        <div class="publisher-controls mt-2">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <small class="text-muted fw-bold">Publishers</small>
                            </div>
                            <div class="publisher-list">
                                ${pipeline.destinations.map(dest => {
                                    let statusText = 'Enabled';
                                    let statusClass = 'text-success';
                                    let statusIcon = '';
                                    let toggleEnabled = true;
                                    let toggleChecked = dest.enabled !== false;
                                    
                                    // Determine status based on current state
                                    if (dest.auto_disabled) {
                                        statusText = 'Auto-Disabled';
                                        statusClass = 'text-danger';
                                        statusIcon = '<i class="fas fa-exclamation-triangle me-1"></i>';
                                        toggleEnabled = false;
                                        toggleChecked = false;
                                    } else if (dest.is_paused) {
                                        // Paused state - toggle OFF but remains enabled (clickable)
                                        statusText = `Paused (${dest.frame_count}/${dest.max_frames} frames)`;
                                        statusClass = 'text-warning';
                                        statusIcon = '<i class="fas fa-pause-circle me-1"></i>';
                                        toggleEnabled = true;
                                        toggleChecked = false;  // Turn toggle OFF when paused
                                    } else if (dest.enabled === false) {
                                        statusText = 'Disabled';
                                        statusClass = 'text-muted';
                                        toggleEnabled = true;
                                        toggleChecked = false;
                                    } else if (dest.failure_count && dest.failure_count > 0) {
                                        statusText = `Error (${dest.failure_count} failures)`;
                                        statusClass = 'text-warning';
                                        statusIcon = '<i class="fas fa-exclamation-circle me-1"></i>';
                                        toggleEnabled = true;
                                        toggleChecked = true;
                                    } else if (dest.frame_count && dest.max_frames) {
                                        // Show progress when frames are being tracked
                                        statusText = `Active (${dest.frame_count}/${dest.max_frames} frames)`;
                                        statusClass = 'text-success';
                                        toggleChecked = true;
                                    }
                                    
                                    return `
                                    <div class="d-flex justify-content-between align-items-center py-1 px-2 mb-1 rounded" style="background-color: rgba(0,0,0,0.05);">
                                        <div class="d-flex align-items-center flex-grow-1">
                                            <span class="badge bg-secondary me-2">${dest.type.toUpperCase()}</span>
                                            <div class="d-flex flex-column">
                                                <small class="${statusClass}">${statusIcon}${statusText}</small>
                                                ${dest.last_error ? `<small class="text-danger" style="font-size: 10px;" title="${dest.last_error}">Error: ${dest.last_error.length > 30 ? dest.last_error.substring(0, 30) + '...' : dest.last_error}</small>` : ''}
                                                ${dest.is_paused ? `<small class="text-info" style="font-size: 10px;"><i class="fas fa-info-circle me-1"></i>Toggle to resume</small>` : ''}
                                            </div>
                                        </div>
                                        <div class="d-flex align-items-center gap-1">
                                            <label class="destination-toggle-small ${dest.is_paused ? 'paused' : ''} ms-1">
                                                <input type="checkbox" 
                                                       ${toggleChecked ? 'checked' : ''}
                                                       ${pipeline.status !== 'running' || !toggleEnabled ? 'disabled' : ''}
                                                       onchange="togglePublisher('${pipeline.id}', '${dest.id}', this.checked)">
                                                <span class="destination-slider-small"></span>
                                            </label>
                                        </div>
                                    </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                    
                    <div class="card-footer d-flex gap-2 py-1 align-items-center">
                        <button class="btn btn-sm ${pipeline.status === 'running' ? 'btn-warning' : pipeline.status === 'starting' ? 'btn-secondary' : 'btn-success'}" 
                                onclick="${pipeline.status === 'running' ? 'stopPipeline' : 'startPipeline'}('${pipeline.id}')"
                                ${pipeline.status === 'starting' ? 'disabled' : ''}
                                style="flex: 2;">
                            <i class="fas fa-${pipeline.status === 'running' ? 'stop' : pipeline.status === 'starting' ? 'spinner fa-spin' : 'play'} me-1"></i>
                            ${pipeline.status === 'running' ? 'Stop' : pipeline.status === 'starting' ? 'Starting...' : 'Start'}
                        </button>
                        
                        <div class="d-flex align-items-center justify-content-center" style="flex: 1;">
                            <small class="text-muted me-2" style="font-size: 14px;">Inference:</small>
                            <label class="inference-toggle">
                                <input type="checkbox" 
                                       ${(pipeline.inference_enabled === true || pipeline.inference_enabled === undefined) ? 'checked' : ''} 
                                       ${pipeline.status !== 'running' ? 'disabled' : ''}
                                       onchange="toggleInference('${pipeline.id}', this.checked)">
                                <span class="inference-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    container.innerHTML = html;
    
    // Force layout recalculation to fix Bootstrap grid issues when switching views
    container.offsetHeight;
    
    // Load thumbnails for pipelines that aren't showing live previews
    filteredPipelines.forEach(pipeline => {
        if (!activePreviews.has(pipeline.id)) {
            console.log(`Loading thumbnail for pipeline ${pipeline.id} (status: ${pipeline.status})`);
            // Always try to load thumbnails, regardless of status
            setTimeout(() => loadThumbnail(pipeline.id), 100);
        }
    });
    
    // Additional pass specifically for stopped pipelines to ensure thumbnails show
    setTimeout(() => {
        filteredPipelines.forEach(pipeline => {
            if (pipeline.status === 'stopped' && !activePreviews.has(pipeline.id)) {
                console.log(`Secondary thumbnail load attempt for stopped pipeline ${pipeline.id}`);
                forceShowThumbnailForStopped(pipeline.id);
            }
        });
    }, 500);
    
    // Restore active previews
    activePreviews.forEach(pipelineId => {
        const pipeline = filteredPipelines.find(p => p.id === pipelineId);
        if (pipeline && pipeline.status === 'running') {
            startPreviewStream(pipelineId);
            updatePreviewContainerVisibility(pipelineId, true);
        }
    });
}

// Render list view
function renderListView() {
    const tbody = document.getElementById('pipelineTableBody');
    
    const html = filteredPipelines.map(pipeline => {
        const statusColor = getStatusColor(pipeline.status);
        const sourceInfo = getSourceInfo(pipeline);
        const modelInfo = getModelInfo(pipeline);
        const deviceInfo = getDeviceInfo(pipeline);
        const createdDate = new Date(pipeline.created_date).toLocaleDateString();
        const isPreviewActive = activePreviews.has(pipeline.id);
        
        return `
            <tr data-pipeline-id="${pipeline.id}" class="${isPreviewActive ? 'preview-enabled' : ''}" 
                ${isPreviewActive ? `onmouseenter="showListPreview('${pipeline.id}')" onmouseleave="hideListPreview()"` : ''}>
                <td>
                    <div>
                        <strong>${pipeline.name}</strong>
                        ${pipeline.description ? `<br><small class="text-muted">${pipeline.description}</small>` : ''}
                    </div>
                </td>
                <td><span class="badge bg-${statusColor}">${capitalizeStatus(pipeline.status)}</span></td>
                <td>
                    ${pipeline.status === 'running' ? `
                        <div class="d-flex align-items-center justify-content-center">
                            <label class="inference-toggle compact">
                                <input type="checkbox" 
                                       ${(pipeline.inference_enabled === true || pipeline.inference_enabled === undefined) ? 'checked' : ''} 
                                       onchange="toggleInference('${pipeline.id}', this.checked)">
                                <span class="inference-slider"></span>
                            </label>
                        </div>
                    ` : '<span class="text-muted">-</span>'}
                </td>
                <td>
                    <div>
                        <strong>${sourceInfo.type}</strong>
                        <br><small class="text-muted source-details" title="${sourceInfo.details}">${sourceInfo.details}</small>
                    </div>
                </td>
                <td>
                    <div>
                        <strong>${modelInfo.engine}</strong>
                        <br><small class="text-muted">${modelInfo.model}</small>
                    </div>
                </td>
                <td><span class="badge bg-secondary">${deviceInfo.display}</span></td>
                <td>
                    <div class="d-flex flex-wrap gap-1">
                        ${pipeline.destinations && pipeline.destinations.length > 0 ? 
                            pipeline.destinations.map(dest => {
                                return `<span class="badge bg-secondary">${dest.type}</span>`;
                            }).join('') 
                            : '<span class="text-muted small">None</span>'
                        }
                    </div>
                </td>
                <td>
                    <span class="text-info" id="list-fps-${pipeline.id}">${(pipeline.stats && pipeline.stats.fps !== undefined) ? pipeline.stats.fps : (pipeline.fps !== undefined) ? pipeline.fps : '0.0'}</span>
                </td>
                <td>
                    <span id="list-latency-${pipeline.id}" style="color: #ffc107;">${(pipeline.stats && pipeline.stats.latency_ms !== undefined) ? pipeline.stats.latency_ms + 'ms' : (pipeline.latency_ms !== undefined) ? pipeline.latency_ms + 'ms' : '0ms'}</span>
                </td>
                <td>
                    <span class="text-success" id="list-uptime-${pipeline.id}">${pipeline.status === 'running' ? (pipeline.uptime || '0s') : '0s'}</span>
                </td>
                <td><small>${createdDate}</small></td>
                <td>
                    <div class="btn-group btn-group-sm">
                        <button class="btn ${pipeline.status === 'running' ? 'btn-warning' : pipeline.status === 'starting' ? 'btn-secondary' : 'btn-success'}" 
                                onclick="${pipeline.status === 'running' ? 'stopPipeline' : 'startPipeline'}('${pipeline.id}')" 
                                ${pipeline.status === 'starting' ? 'disabled' : ''}
                                title="${pipeline.status === 'running' ? 'Stop' : pipeline.status === 'starting' ? 'Starting...' : 'Start'} pipeline">
                            <i class="fas fa-${pipeline.status === 'running' ? 'stop' : pipeline.status === 'starting' ? 'spinner fa-spin' : 'play'}"></i>
                        </button>
                        <button class="btn btn-outline-primary" onclick="showPipelineDetails('${pipeline.id}')" title="Details">
                            <i class="fas fa-info-circle"></i>
                        </button>
                        <button class="btn btn-outline-secondary" onclick="editPipeline('${pipeline.id}')" title="Edit">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="btn btn-outline-secondary" onclick="duplicatePipeline('${pipeline.id}')" title="Duplicate">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button class="btn btn-outline-info" onclick="exportPipeline('${pipeline.id}')" title="Export">
                            <i class="fas fa-download"></i>
                        </button>
                        <button class="btn btn-outline-danger" onclick="deletePipeline('${pipeline.id}')" title="Delete">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }).join('');
    
    tbody.innerHTML = html;
    
    // Restore active preview functionality for list view
    activePreviews.forEach(pipelineId => {
        const pipeline = filteredPipelines.find(p => p.id === pipelineId);
        if (pipeline && pipeline.status === 'running') {
            const rowElement = document.querySelector(`tr[data-pipeline-id="${pipelineId}"]`);
            if (rowElement) {
                rowElement.className = 'preview-enabled';
                rowElement.onmouseenter = () => showListPreview(pipelineId);
                rowElement.onmouseleave = () => hideListPreview();
            }
        }
    });
}

// Helper functions
function getStatusColor(status) {
    switch (status) {
        case 'running': return 'success';
        case 'stopped': return 'secondary';
        case 'starting': return 'warning';
        case 'error': return 'danger';
        default: return 'light';
    }
}

function capitalizeStatus(status) {
    if (!status) return status;
    return status.charAt(0).toUpperCase() + status.slice(1);
}

// Helper function to sanitize URLs by removing credentials
function sanitizeUrl(url) {
    if (!url || typeof url !== 'string') return url;
    
    // Regex to match protocol://username:password@host:port/path
    // and replace with protocol://host:port/path
    const regex = /^(https?|rtsp|ftp):\/\/[^:\/\s]+:[^@\/\s]*@(.+)$/i;
    const match = url.match(regex);
    
    if (match) {
        return `${match[1]}://${match[2]}`;
    }
    
    return url; // Return original if no credentials found
}

// Wait for pipeline to be ready to stream (frames available)
async function waitForPipelineReady(pipelineId, maxWaitTime = 10000) {
    const startTime = Date.now();
    const pollInterval = 500; // Check every 500ms
    
    console.log(`Waiting for pipeline ${pipelineId} to be ready...`);
    
    while (Date.now() - startTime < maxWaitTime) {
        try {
            // Check if stream endpoint is ready by making a HEAD request
            const response = await fetch(`/api/pipeline/${pipelineId}/stream?t=${Date.now()}`, {
                method: 'HEAD'
            });
            
            // If we get a successful response (not 503), pipeline is ready
            if (response.ok) {
                console.log(`Pipeline ${pipelineId} is ready after ${Date.now() - startTime}ms`);
                updateSinglePipelineState(pipelineId, 'running');
                
                // Load thumbnail for pipelines without active previews
                setTimeout(() => {
                    if (!activePreviews.has(pipelineId)) {
                        loadThumbnail(pipelineId);
                    }
                }, 1000);
                
                return true;
            } else if (response.status === 503) {
                // Pipeline is still warming up, continue waiting
                console.log(`Pipeline ${pipelineId} still warming up (${Date.now() - startTime}ms elapsed)...`);
            } else {
                // Other error - pipeline failed to start properly
                console.error(`Pipeline ${pipelineId} returned error status: ${response.status}`);
                updateSinglePipelineState(pipelineId, 'error');
                return false;
            }
        } catch (error) {
            console.warn(`Error checking pipeline ${pipelineId} readiness:`, error);
        }
        
        // Wait before next check
        await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
    
    // Timeout - pipeline took too long to start
    console.warn(`Pipeline ${pipelineId} timed out waiting for ready state`);
    
    // Check final status to determine if it's running or error
    try {
        const statusResponse = await fetch(`/api/pipeline/${pipelineId}/status`);
        if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            if (statusData.status === 'running') {
                console.log(`Pipeline ${pipelineId} is running but frames not yet available`);
                updateSinglePipelineState(pipelineId, 'running');
                return true;
            }
        }
    } catch (e) {
        console.error(`Error getting final status for pipeline ${pipelineId}:`, e);
    }
    
    updateSinglePipelineState(pipelineId, 'error');
    return false;
}

function getSourceInfo(pipeline) {
    const frameSource = pipeline.frame_source || {};
    const type = frameSource.capture_type || frameSource.type || 'Unknown';
    const config = frameSource.config || {};
    
    let details = '';
    let displayType = '';
    
    switch (type) {
        case 'webcam':
            details = `Camera ${config.source || 0}`;
            displayType = 'Webcam';
            break;
        case 'ip_camera':
        case 'rtsp':
            // Sanitize URL to remove credentials for display
            details = sanitizeUrl(config.source) || 'No URL';
            displayType = 'IP Camera';
            break;
        case 'realsense':
            details = `${config.width || 1280}x${config.height || 720}@${config.fps || 30}fps`;
            displayType = 'RealSense';
            break;
        case 'video_file':
            details = config.source ? config.source.split('\\').pop() || config.source.split('/').pop() : 'No path';
            displayType = 'Video File';
            break;
        case 'image_folder':
            details = config.source ? config.source.split('\\').pop() || config.source.split('/').pop() : 'No path';
            displayType = 'Images';
            break;
        default:
            details = 'No config';
            displayType = type.replace('_', ' ').toUpperCase();
    }
    
    return { 
        type: type.replace('_', ' ').toUpperCase(), 
        display: displayType,
        details 
    };
}

function getModelInfo(pipeline) {
    const model = pipeline.model || {};
    
    // Extract meaningful model name from the ID
    let modelName = 'No model';
    let modelBadge = 'None';
    
    if (model.id) {
        // Remove the hash suffix to get a cleaner name
        // e.g., "yolov8n_95a24496" -> "yolov8n"
        // e.g., "Deployment-bird-feeder-seg_2d406115" -> "Deployment-bird-feeder-seg"
        const cleanName = model.id.replace(/_[a-f0-9]{8}$/, '');
        
        // For Geti models, clean up common deployment prefixes/suffixes
        if (cleanName.startsWith('Deployment-')) {
            modelName = cleanName.replace('Deployment-', '');
        } else if (cleanName.includes('geti_sdk-deployment')) {
            modelName = cleanName.replace('geti_sdk-deployment', 'Geti Model');
            // Remove any remaining parentheses and numbers
            modelName = modelName.replace(/\s*\(\d+\)\s*/, '').trim();
        } else {
            modelName = cleanName;
        }
        
        // Create a badge version (shorter)
        if (modelName.length > 15) {
            // For very long names, take first 12 chars + ...
            modelBadge = modelName.substring(0, 12) + '...';
        } else {
            modelBadge = modelName;
        }
        
        // If the cleaned name is still too long, show the full ID
        if (modelName.length > 25) {
            modelName = model.id;
            modelBadge = model.id.substring(0, 12) + '...';
        }
    }
    
    // Map engine types to display names (dynamic)
    let engineDisplayNames = {};
    let engineBadgeNames = {};
    
    // Build dynamic mapping from available engines
    if (availableEngineTypes && availableEngineTypes.length > 0) {
        availableEngineTypes.forEach(engine => {
            engineDisplayNames[engine.type] = engine.name;
            engineBadgeNames[engine.type] = engine.name;
        });
    }
    
    // Fallback to static mapping for backwards compatibility
    const fallbackDisplayNames = {
        'ultralytics': 'Ultralytics YOLO',
        'geti': 'Geti',
        'pass': 'Pass Engine'
    };
    
    const fallbackBadgeNames = {
        'ultralytics': 'Ultralytics',
        'geti': 'Geti',
        'pass': 'Pass'
    };
    
    const engineName = engineDisplayNames[model.engine_type] || 
                      fallbackDisplayNames[model.engine_type] || 
                      model.engine_type || 'Unknown';
    const engineBadge = engineBadgeNames[model.engine_type] || 
                       fallbackBadgeNames[model.engine_type] || 
                       model.engine_type || 'Unknown';
    
    return {
        engine: engineName,
        engineBadge: engineBadge,
        model: modelName,
        modelBadge: modelBadge
    };
}

function getDeviceInfo(pipeline) {
    const model = pipeline.model || {};
    const device = model.device || 'cpu';
    
    // Map device names to display-friendly names
    const deviceMappings = {
        'cpu': 'CPU',
        'intel:cpu': 'Intel CPU',
        'amd:cpu': 'AMD CPU',
        'intel:gpu': 'Intel GPU',
        'cuda': 'NVIDIA GPU',
        'nvidia:gpu': 'NVIDIA GPU',
        'amd:gpu': 'AMD GPU',
        'intel:npu': 'Intel NPU',
        'mps': 'Apple Silicon',
        'apple:neural_engine': 'Apple Neural'
    };
    
    return {
        display: deviceMappings[device] || device.toUpperCase(),
        original: device
    };
}

// Pipeline actions
async function startPipeline(pipelineId) {
    // Show immediate loading feedback
    setButtonLoadingState(pipelineId, true, 'Starting...');
    updateSinglePipelineState(pipelineId, 'starting');
    
    try {
        const response = await fetch(`/api/pipeline/${pipelineId}/start`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (response.ok) {
            showAlert('success', 'Pipeline started successfully');
            
            // Keep pipeline in 'starting' state until we verify it's ready to stream
            // Poll the status endpoint to check if pipeline is truly running and has frames
            await waitForPipelineReady(pipelineId);
            
            // Update statistics with a lightweight refresh that preserves other previews
            refreshPipelines(true);
        } else {
            showAlert('error', `Failed to start pipeline: ${result.error}`);
            // Revert to stopped state on error
            updateSinglePipelineState(pipelineId, 'stopped');
        }
    } catch (error) {
        showAlert('error', `Error starting pipeline: ${error.message}`);
        // Revert to stopped state on error
        updateSinglePipelineState(pipelineId, 'stopped');
    } finally {
        // Clear loading state
        setButtonLoadingState(pipelineId, false);
    }
}

// Start pipeline and automatically enable preview - used by play buttons
async function startPipelineWithPreview(pipelineId) {
    // Show immediate loading feedback
    setButtonLoadingState(pipelineId, true, 'Starting...');
    updateSinglePipelineState(pipelineId, 'starting');
    
    try {
        const response = await fetch(`/api/pipeline/${pipelineId}/start`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (response.ok) {
            showAlert('success', 'Pipeline started successfully');
            
            // Keep pipeline in 'starting' state until we verify it's ready to stream
            // Poll the status endpoint to check if pipeline is truly running and has frames
            const isReady = await waitForPipelineReady(pipelineId);
            
            if (isReady) {
                // Automatically enable preview now that pipeline is confirmed ready
                if (!activePreviews.has(pipelineId)) {
                    console.log(`Auto-enabling preview for pipeline ${pipelineId}`);
                    togglePreview(pipelineId);
                }
            }
            
            // Update statistics with a lightweight refresh that preserves other previews
            refreshPipelines(true);
        } else {
            showAlert('error', `Failed to start pipeline: ${result.error}`);
            // Revert to stopped state on error
            updateSinglePipelineState(pipelineId, 'stopped');
        }
    } catch (error) {
        showAlert('error', `Error starting pipeline: ${error.message}`);
        // Revert to stopped state on error
        updateSinglePipelineState(pipelineId, 'stopped');
    } finally {
        // Clear loading state
        setButtonLoadingState(pipelineId, false);
    }
}

async function stopPipeline(pipelineId) {
    try {
        const response = await fetch(`/api/pipeline/${pipelineId}/stop`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (response.ok) {
            showAlert('success', 'Pipeline stopped successfully');
            
            // Gracefully stop preview for this specific pipeline
            if (activePreviews.has(pipelineId)) {
                stopPreviewStream(pipelineId);
                activePreviews.delete(pipelineId);
                // Don't call updatePreviewContainerVisibility here as it interferes with thumbnail display
                // Just hide the live preview container directly
                const previewContainer = document.querySelector(`#preview-${pipelineId}`);
                if (previewContainer) {
                    previewContainer.style.display = 'none';
                }
            }
            
            // Update only this pipeline's UI state without full refresh
            updateSinglePipelineState(pipelineId, 'stopped');
            
            // Force show thumbnail for the stopped pipeline with multiple attempts
            setTimeout(() => {
                console.log(`First attempt: Loading thumbnail for stopped pipeline ${pipelineId}`);
                forceShowThumbnailForStopped(pipelineId);
            }, 500);
            
            setTimeout(() => {
                console.log(`Second attempt: Loading thumbnail for stopped pipeline ${pipelineId}`);
                forceShowThumbnailForStopped(pipelineId);
            }, 1500);
            
            // Update statistics with a lightweight refresh that preserves other previews
            refreshPipelines(true);
        } else {
            showAlert('error', `Failed to stop pipeline: ${result.error}`);
        }
    } catch (error) {
        showAlert('error', `Error stopping pipeline: ${error.message}`);
    }
}

async function deletePipeline(pipelineId) {
    if (confirm('Are you sure you want to delete this pipeline? This action cannot be undone.')) {
        try {
            const response = await fetch(`/api/pipeline/${pipelineId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            
            if (response.ok) {
                showAlert('success', 'Pipeline deleted successfully');
                
                // Clean up preview state for deleted pipeline
                if (activePreviews.has(pipelineId)) {
                    stopPreviewStream(pipelineId);
                    activePreviews.delete(pipelineId);
                }
                
                // Remove pipeline from UI without full refresh
                const cardElement = document.querySelector(`[data-pipeline-id="${pipelineId}"]`);
                const rowElement = document.querySelector(`tr[data-pipeline-id="${pipelineId}"]`);
                
                if (cardElement) {
                    // Remove the entire column wrapper (col-xl-4 col-lg-6 etc.)
                    cardElement.remove();
                }
                if (rowElement) {
                    rowElement.remove();
                }
                
                // Remove from local data
                allPipelines = allPipelines.filter(p => p.id !== pipelineId);
                filteredPipelines = filteredPipelines.filter(p => p.id !== pipelineId);
                
                // Statistics are now on the telemetry page
                
                // Show empty state if no pipelines remain
                if (filteredPipelines.length === 0) {
                    document.getElementById('pipelinesContainer').style.display = 'none';
                    document.getElementById('emptyState').style.display = 'block';
                }
            } else {
                showAlert('error', `Failed to delete pipeline: ${result.error}`);
            }
        } catch (error) {
            showAlert('error', `Error deleting pipeline: ${error.message}`);
        }
    }
}

function editPipeline(pipelineId) {
    // Redirect to pipeline builder with edit mode
    window.location.href = `/pipeline-builder?edit=${pipelineId}`;
}

async function duplicatePipeline(pipelineId) {
    try {
        // First, get the pipeline details
        const response = await fetch(`/api/pipeline/${pipelineId}`);
        const originalPipeline = await response.json();
        
        if (!response.ok) {
            showAlert('error', `Failed to load pipeline details: ${originalPipeline.error}`);
            return;
        }
        
        // Generate new name with number suffix
        const originalName = originalPipeline.name;
        const newName = generateDuplicateName(originalName);
        
        // Create duplicate pipeline data
        const duplicateData = {
            name: newName,
            description: originalPipeline.description ? `Copy of ${originalPipeline.description}` : `Copy of ${originalName}`,
            frame_source: originalPipeline.frame_source,
            model: originalPipeline.model,
            destinations: originalPipeline.destinations || []
        };
        
        // Create the new pipeline
        const createResponse = await fetch('/api/pipeline/create', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(duplicateData)
        });
        
        const result = await createResponse.json();
        
        if (createResponse.ok) {
            showAlert('success', `Pipeline "${newName}" created successfully`);
            
            // Add the new pipeline to local data without full refresh
            const newPipeline = result.pipeline || {
                id: result.pipeline_id,
                name: newName,
                description: duplicateData.description,
                status: 'stopped',
                created_date: new Date().toISOString(),
                frame_source: duplicateData.frame_source,
                model: duplicateData.model,
                destinations: duplicateData.destinations
            };
            
            allPipelines.push(newPipeline);
            
            // Statistics are now on the telemetry page
            
            // Re-filter and render without scrolling
            filterPipelines();
        } else {
            showAlert('error', `Failed to duplicate pipeline: ${result.error}`);
        }
    } catch (error) {
        showAlert('error', `Error duplicating pipeline: ${error.message}`);
    }
}

// Helper function to generate duplicate name with number suffix
function generateDuplicateName(originalName) {
    const existingNames = allPipelines.map(p => p.name);
    
    // Check if name already has a number suffix
    const match = originalName.match(/^(.+?)\s*\((\d+)\)$/);
    
    let baseName, startNumber;
    if (match) {
        baseName = match[1];
        startNumber = parseInt(match[2]);
    } else {
        baseName = originalName;
        startNumber = 0;
    }
    
    // Find the next available number
    let counter = startNumber + 1;
    let newName;
    
    do {
        newName = `${baseName} (${counter})`;
        counter++;
    } while (existingNames.includes(newName));
    
    return newName;
}

// Export pipeline function
async function exportPipeline(pipelineId) {
    try {
        const pipeline = allPipelines.find(p => p.id === pipelineId);
        if (!pipeline) {
            showAlert('error', 'Pipeline not found');
            return;
        }
        
        // Show loading state
        showAlert('info', 'Preparing pipeline export...');
        
        // Create a temporary link to download the file
        const response = await fetch(`/api/pipeline/${pipelineId}/export`);
        
        if (!response.ok) {
            const result = await response.json();
            showAlert('error', `Failed to export pipeline: ${result.error}`);
            return;
        }
        
        // Get the filename from the response headers or use a default
        const contentDisposition = response.headers.get('Content-Disposition');
        let filename = `${pipeline.name.replace(/[^a-z0-9]/gi, '_')}_export.zip`;
        if (contentDisposition) {
            const match = contentDisposition.match(/filename="([^"]+)"/);
            if (match) {
                filename = match[1];
            }
        }
        
        // Create blob and download
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
        
        showAlert('success', `Pipeline "${pipeline.name}" exported successfully`);
        
    } catch (error) {
        showAlert('error', `Error exporting pipeline: ${error.message}`);
    }
}

// Inference control functions
function toggleInference(pipelineId, enabled) {
    if (enabled) {
        enableInference(pipelineId);
    } else {
        disableInference(pipelineId);
    }
}

async function enableInference(pipelineId) {
    try {
        const response = await fetch(`/api/pipeline/${pipelineId}/inference/enable`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (response.ok) {
            showAlert('success', 'Inference enabled successfully');
            
            // Update the local pipeline data
            const pipeline = allPipelines.find(p => p.id === pipelineId);
            if (pipeline) {
                pipeline.inference_enabled = true;
                
                // Update inference badge in card header
                const cardElement = document.querySelector(`[data-pipeline-id="${pipelineId}"]`);
                if (cardElement) {
                    const inferenceBadge = cardElement.querySelector('.badge:nth-child(2)');
                    if (inferenceBadge) {
                        inferenceBadge.className = 'badge bg-info badge-sm';
                        inferenceBadge.innerHTML = '<i class="fas fa-brain me-1"></i>Inference ON';
                    }
                    
                    // Update inference button
                    const inferenceBtn = cardElement.querySelector('.card-footer button:nth-child(2)');
                    if (inferenceBtn) {
                        inferenceBtn.className = 'btn btn-sm btn-danger';
                        inferenceBtn.title = 'Disable Inference';
                        inferenceBtn.onclick = () => disableInference(pipelineId);
                    }
                }
                
                // Update list view inference cell
                const rowElement = document.querySelector(`tr[data-pipeline-id="${pipelineId}"]`);
                if (rowElement) {
                    const inferenceCell = rowElement.querySelector('td:nth-child(3)');
                    if (inferenceCell) {
                        inferenceCell.innerHTML = `
                            <div class="d-flex align-items-center">
                                <small class="text-muted me-2" style="font-size: 12px;">Inference:</small>
                                <label class="inference-toggle compact">
                                    <input type="checkbox" 
                                           checked 
                                           onchange="toggleInference('${pipelineId}', this.checked)">
                                    <span class="inference-slider"></span>
                                </label>
                            </div>
                        `;
                    }
                }
            }
            
            refreshPipelines(true); // Preserve previews
        } else {
            showAlert('error', `Failed to enable inference: ${result.error}`);
        }
    } catch (error) {
        showAlert('error', `Error enabling inference: ${error.message}`);
    }
}

async function disableInference(pipelineId) {
    try {
        const response = await fetch(`/api/pipeline/${pipelineId}/inference/disable`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (response.ok) {
            showAlert('success', 'Inference disabled successfully');
            
            // Update the local pipeline data
            const pipeline = allPipelines.find(p => p.id === pipelineId);
            if (pipeline) {
                pipeline.inference_enabled = false;
                
                // Update inference badge in card header
                const cardElement = document.querySelector(`[data-pipeline-id="${pipelineId}"]`);
                if (cardElement) {
                    const inferenceBadge = cardElement.querySelector('.badge:nth-child(2)');
                    if (inferenceBadge) {
                        inferenceBadge.className = 'badge bg-secondary badge-sm';
                        inferenceBadge.innerHTML = '<i class="fas fa-brain me-1"></i>Inference OFF';
                    }
                    
                    // Update inference button
                    const inferenceBtn = cardElement.querySelector('.card-footer button:nth-child(2)');
                    if (inferenceBtn) {
                        inferenceBtn.className = 'btn btn-sm btn-success';
                        inferenceBtn.title = 'Enable Inference';
                        inferenceBtn.onclick = () => enableInference(pipelineId);
                    }
                }
                
                // Update list view inference cell
                const rowElement = document.querySelector(`tr[data-pipeline-id="${pipelineId}"]`);
                if (rowElement) {
                    const inferenceCell = rowElement.querySelector('td:nth-child(3)');
                    if (inferenceCell) {
                        inferenceCell.innerHTML = `
                            <div class="d-flex align-items-center">
                                <small class="text-muted me-2" style="font-size: 12px;">Inference:</small>
                                <label class="inference-toggle compact">
                                    <input type="checkbox" 
                                           onchange="toggleInference('${pipelineId}', this.checked)">
                                    <span class="inference-slider"></span>
                                </label>
                            </div>
                        `;
                    }
                }
            }
            
            refreshPipelines(true); // Preserve previews
        } else {
            showAlert('error', `Failed to disable inference: ${result.error}`);
        }
    } catch (error) {
        showAlert('error', `Error disabling inference: ${error.message}`);
    }
}

// Preview toggle switch functionality
function togglePreviewSwitch(pipelineId, enabled) {
    if (enabled) {
        startPreviewStream(pipelineId);
        activePreviews.add(pipelineId);
        updatePreviewContainerVisibility(pipelineId, true);
        
        // In list view, enable hover functionality
        if (currentViewMode === 'list') {
            const rowElement = document.querySelector(`tr[data-pipeline-id="${pipelineId}"]`);
            if (rowElement) {
                rowElement.className = 'preview-enabled';
                rowElement.onmouseenter = () => showListPreview(pipelineId);
                rowElement.onmouseleave = () => hideListPreview();
            }
        }
    } else {
        stopPreviewStream(pipelineId);
        activePreviews.delete(pipelineId);
        updatePreviewContainerVisibility(pipelineId, false);
        
        // In list view, disable hover functionality and hide any active preview
        if (currentViewMode === 'list') {
            hideListPreview(); // Hide any currently shown preview overlay
            const rowElement = document.querySelector(`tr[data-pipeline-id="${pipelineId}"]`);
            if (rowElement) {
                rowElement.className = '';
                rowElement.onmouseenter = null;
                rowElement.onmouseleave = null;
            }
        }
    }
}

// Update preview container visibility for toggle switches
function updatePreviewContainerVisibility(pipelineId, isActive) {
    const card = document.querySelector(`[data-pipeline-id="${pipelineId}"]`);
    if (card) {
        const previewContainer = card.querySelector(`#preview-${pipelineId}`);
        const placeholder = card.querySelector('.preview-placeholder');
        const thumbnailContainer = card.querySelector(`#thumbnail-${pipelineId}`);
        
        if (previewContainer && placeholder) {
            if (isActive) {
                previewContainer.style.display = 'block';
                placeholder.style.display = 'none';
                if (thumbnailContainer) {
                    thumbnailContainer.style.display = 'none';
                }
            } else {
                previewContainer.style.display = 'none';
                // Check if we should show thumbnail or default placeholder
                updateThumbnailVisibility(pipelineId, false);
            }
        }
    }
}

// Preview functionality
function togglePreview(pipelineId) {
    if (activePreviews.has(pipelineId)) {
        stopPreviewStream(pipelineId);
        activePreviews.delete(pipelineId);
        updatePreviewContainerVisibility(pipelineId, false);
    } else {
        startPreviewStream(pipelineId);
        activePreviews.add(pipelineId);
        updatePreviewContainerVisibility(pipelineId, true);
    }
}

function startPreviewStream(pipelineId) {
    const previewImg = document.querySelector(`#preview-${pipelineId} .preview-stream`);
    if (!previewImg) {
        console.warn(`Preview image element not found for pipeline ${pipelineId}`);
        return;
    }
    
    // Check if stream is already active and the img element has content
    if (previewImg.src && 
        previewImg.src.includes(`/api/pipeline/${pipelineId}/stream`) && 
        previewImg.complete && 
        previewImg.naturalWidth > 0) {
        console.log(`Stream already active and loaded for pipeline ${pipelineId}, skipping restart`);
        previewImg.style.opacity = '1'; // Ensure it's visible
        return;
    }
    
    console.log(`Starting stream for pipeline ${pipelineId}`);
    const streamUrl = `/api/pipeline/${pipelineId}/stream?t=${Date.now()}`;
    previewImg.src = streamUrl;
    
    // Optimize image loading for performance
    previewImg.style.imageRendering = 'auto';  // Let browser optimize
    previewImg.decoding = 'async';  // Async decoding for better performance
    
    // Add load timeout - increased for pipeline warmup time
    const timeout = setTimeout(() => {
        console.warn(`Preview stream timeout for pipeline ${pipelineId}`);
        activePreviews.delete(pipelineId);
        updatePreviewContainerVisibility(pipelineId, false);
        showAlert('warning', 'Preview stream timed out. Pipeline may still be starting.');
    }, 20000); // Increased timeout to allow for pipeline warmup
    
    previewImg.onload = function() {
        clearTimeout(timeout);
        console.log(`Stream loaded successfully for pipeline ${pipelineId}`);
        // Optional: Add a fade-in effect for smoother transitions
        this.style.opacity = '1';
    };
    
    previewImg.onerror = function() {
        clearTimeout(timeout);
        console.warn(`Preview stream failed for pipeline ${pipelineId}`);
        
        // Check if this is a 503 error (pipeline warming up) by making a quick fetch
        fetch(`/api/pipeline/${pipelineId}/stream?t=${Date.now()}`)
            .then(response => {
                if (response.status === 503) {
                    // Pipeline is warming up, retry after a short delay
                    console.log(`Pipeline ${pipelineId} is warming up, retrying in 2 seconds...`);
                    showAlert('info', 'Pipeline is starting up, retrying preview...');
                    setTimeout(() => {
                        if (activePreviews.has(pipelineId)) {
                            console.log(`Retrying stream for pipeline ${pipelineId} after warmup`);
                            startPreviewStream(pipelineId);
                        }
                    }, 2000);
                } else if (response.status === 404 || response.status === 400) {
                    // Pipeline not found or not running - verify actual status before giving up
                    console.log(`Stream returned ${response.status}, checking pipeline status...`);
                    fetch(`/api/pipeline/${pipelineId}/status`)
                        .then(statusResponse => statusResponse.json())
                        .then(statusData => {
                            if (statusData.status === 'running') {
                                // Pipeline is running but stream failed - retry
                                console.log(`Pipeline is running, retrying stream...`);
                                setTimeout(() => {
                                    if (activePreviews.has(pipelineId)) {
                                        startPreviewStream(pipelineId);
                                    }
                                }, 2000);
                            } else {
                                // Pipeline is actually not running
                                console.log(`Pipeline confirmed not running: ${statusData.status}`);
                                activePreviews.delete(pipelineId);
                                updatePreviewContainerVisibility(pipelineId, false);
                                showAlert('warning', 'Pipeline is not running. Please start it first.');
                            }
                        })
                        .catch(err => {
                            console.error(`Error checking pipeline status:`, err);
                            activePreviews.delete(pipelineId);
                            updatePreviewContainerVisibility(pipelineId, false);
                        });
                } else {
                    // Other error
                    console.error(`Stream failed with status ${response.status}`);
                    activePreviews.delete(pipelineId);
                    updatePreviewContainerVisibility(pipelineId, false);
                    showAlert('error', 'Failed to start preview stream.');
                }
            })
            .catch(err => {
                // Network error or other issue
                console.error(`Error checking stream status for pipeline ${pipelineId}:`, err);
                showAlert('warning', 'Could not connect to preview stream. Retrying...');
                
                // Retry once after delay
                setTimeout(() => {
                    if (activePreviews.has(pipelineId)) {
                        console.log(`Retrying stream for pipeline ${pipelineId} after network error`);
                        startPreviewStream(pipelineId);
                    }
                }, 2000);
            });
    };
}

function stopPreviewStream(pipelineId) {
    const previewImg = document.querySelector(`#preview-${pipelineId} .preview-stream`);
    if (previewImg) {
        previewImg.src = '';
        previewImg.onload = null;
        previewImg.onerror = null;
        
        // Generate a fresh thumbnail when stopping the preview stream
        // This captures the current frame as a static image for the user
        setTimeout(() => {
            generateFreshThumbnail(pipelineId);
        }, 300); // Short delay to ensure preview has fully stopped
    }
}

// Helper function to update preview button state
function updatePreviewButtonState(pipelineId, isActive) {
    const card = document.querySelector(`[data-pipeline-id="${pipelineId}"]`);
    if (card) {
        const previewBtn = card.querySelector('.card-footer button:last-child');
        const previewContainer = card.querySelector(`#preview-${pipelineId}`);
        const placeholder = card.querySelector('.preview-placeholder');
        
        if (previewBtn && previewContainer && placeholder) {
            if (isActive) {
                previewBtn.className = 'btn btn-sm btn-danger';
                previewBtn.innerHTML = '<i class="fas fa-eye-slash"></i>';
                previewContainer.style.display = 'block';
                placeholder.style.display = 'none';
            } else {
                previewBtn.className = 'btn btn-sm btn-outline-primary';
                previewBtn.innerHTML = '<i class="fas fa-eye"></i>';
                previewContainer.style.display = 'none';
                placeholder.style.display = 'flex';
            }
        }
    }
}

function openFullPreview(pipelineId, pipelineName) {
    document.getElementById('fullPreviewTitle').textContent = pipelineName;
    
    const fullPreviewImg = document.getElementById('fullPreviewStream');
    const statusDiv = document.getElementById('fullPreviewStatus');
    
    // Use high-quality stream endpoint for full preview
    const streamUrl = `/api/pipeline/${pipelineId}/stream/hq?t=${Date.now()}`;
    fullPreviewImg.src = streamUrl;
    
    // Optimize full preview for performance
    fullPreviewImg.style.imageRendering = 'auto';
    fullPreviewImg.decoding = 'async';
    
    statusDiv.innerHTML = '<small class="text-info"><i class="fas fa-spinner fa-spin me-1"></i>Connecting to high-quality stream...</small>';
    
    fullPreviewImg.onload = function() {
        statusDiv.innerHTML = '<small class="text-success"><i class="fas fa-circle me-1"></i>High-quality stream active</small>';
    };
    
    fullPreviewImg.onerror = function() {
        statusDiv.innerHTML = '<small class="text-danger"><i class="fas fa-exclamation-triangle me-1"></i>High-quality stream unavailable - trying standard quality...</small>';
        
        // Fallback to standard stream if HQ fails
        setTimeout(() => {
            const fallbackUrl = `/api/pipeline/${pipelineId}/stream?t=${Date.now()}`;
            fullPreviewImg.src = fallbackUrl;
            
            fullPreviewImg.onload = function() {
                statusDiv.innerHTML = '<small class="text-warning"><i class="fas fa-circle me-1"></i>Standard quality stream active</small>';
            };
            
            fullPreviewImg.onerror = function() {
                statusDiv.innerHTML = '<small class="text-danger"><i class="fas fa-exclamation-triangle me-1"></i>Stream unavailable</small>';
            };
        }, 1000);
    };
    
    const modal = new bootstrap.Modal(document.getElementById('fullPreviewModal'));
    modal.show();
    
    // Clean up when modal is closed
    document.getElementById('fullPreviewModal').addEventListener('hidden.bs.modal', function() {
        fullPreviewImg.src = '';
        fullPreviewImg.onload = null;
        fullPreviewImg.onerror = null;
        statusDiv.innerHTML = '<small class="text-muted">Stream stopped</small>';
    }, { once: true });
}

// List view preview functionality
function toggleListPreview(pipelineId) {
    if (activePreviews.has(pipelineId)) {
        stopListPreview(pipelineId);
        activePreviews.delete(pipelineId);
    } else {
        startListPreview(pipelineId);
        activePreviews.add(pipelineId);
    }
    
    // Update button state and row hover functionality
    const rowElement = document.querySelector(`tr[data-pipeline-id="${pipelineId}"]`);
    const previewBtn = rowElement.querySelector('.btn-group button:nth-child(3)');
    
    if (activePreviews.has(pipelineId)) {
        previewBtn.className = 'btn btn-danger';
        previewBtn.innerHTML = '<i class="fas fa-eye-slash"></i>';
        rowElement.className = 'preview-enabled';
        rowElement.onmouseenter = () => showListPreview(pipelineId);
        rowElement.onmouseleave = () => hideListPreview();
    } else {
        previewBtn.className = 'btn btn-outline-primary';
        previewBtn.innerHTML = '<i class="fas fa-eye"></i>';
        rowElement.className = '';
        rowElement.onmouseenter = null;
        rowElement.onmouseleave = null;
        hideListPreview();
    }
}

function startListPreview(pipelineId) {
    // List preview streams are handled by hover overlay, no persistent stream needed
    console.log(`List preview enabled for pipeline ${pipelineId}`);
}

function stopListPreview(pipelineId) {
    // Stop any active overlay
    hideListPreview();
    console.log(`List preview disabled for pipeline ${pipelineId}`);
}

function showListPreview(pipelineId) {
    const overlay = document.getElementById('listPreviewOverlay');
    const img = document.getElementById('listPreviewImage');
    const status = document.getElementById('listPreviewStatus');
    
    // Position overlay near mouse cursor
    const handleMouseMove = (e) => {
        overlay.style.left = (e.clientX + 15) + 'px';
        overlay.style.top = (e.clientY - 150) + 'px';
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    overlay.handleMouseMove = handleMouseMove; // Store reference for cleanup
    
    // Set up stream
    const streamUrl = `/api/pipeline/${pipelineId}/stream?t=${Date.now()}`;
    img.src = streamUrl;
    status.textContent = 'Connecting...';
    
    img.onload = function() {
        status.textContent = 'Live Preview';
        overlay.classList.add('show');
    };
    
    img.onerror = function() {
        status.textContent = 'Stream unavailable';
        overlay.classList.add('show');
    };
}

function hideListPreview() {
    const overlay = document.getElementById('listPreviewOverlay');
    const img = document.getElementById('listPreviewImage');
    
    overlay.classList.remove('show');
    
    // Clean up mouse move listener
    if (overlay.handleMouseMove) {
        document.removeEventListener('mousemove', overlay.handleMouseMove);
        overlay.handleMouseMove = null;
    }
    
    // Clean up image
    setTimeout(() => {
        if (!overlay.classList.contains('show')) {
            img.src = '';
            img.onload = null;
            img.onerror = null;
        }
    }, 200);
}

// Thumbnail functionality
async function loadThumbnail(pipelineId) {
    console.log(`Loading thumbnail for pipeline ${pipelineId}`);
    try {
        // Check if thumbnail exists with extra debugging
        console.log(`Checking thumbnail existence for ${pipelineId}...`);
        const existsResponse = await fetch(`/api/pipeline/${pipelineId}/thumbnail/exists`);
        const existsData = await existsResponse.json();
        
        console.log(`Thumbnail exists for ${pipelineId}: ${existsData.has_thumbnail}`);
        
        if (existsData.has_thumbnail) {
            const thumbnailContainer = document.getElementById(`thumbnail-${pipelineId}`);
            const placeholderContainer = document.querySelector(`#preview-${pipelineId}`).parentElement.querySelector('.preview-placeholder');
            
            if (thumbnailContainer && placeholderContainer) {
                console.log(`Found thumbnail and placeholder containers for ${pipelineId}`);
                
                // Load the thumbnail image
                const thumbnailImg = thumbnailContainer.querySelector('.thumbnail-image');
                thumbnailImg.src = `/api/pipeline/${pipelineId}/thumbnail?t=${Date.now()}`;
                
                thumbnailImg.onload = function() {
                    console.log(`Thumbnail loaded successfully for ${pipelineId}`);
                    // Hide the default placeholder and show thumbnail
                    placeholderContainer.style.display = 'none';
                    thumbnailContainer.style.display = 'block';
                };
                
                thumbnailImg.onerror = function() {
                    console.warn(`Failed to load thumbnail image for pipeline ${pipelineId}`);
                    // Show the default placeholder since thumbnail failed to load
                    thumbnailContainer.style.display = 'none';
                    placeholderContainer.style.display = 'flex';
                };
            } else {
                console.warn(`Could not find thumbnail or placeholder containers for ${pipelineId}`);
            }
        } else {
            console.log(`No thumbnail exists for ${pipelineId}, showing default placeholder`);
            // No thumbnail exists, show the default placeholder
            const thumbnailContainer = document.getElementById(`thumbnail-${pipelineId}`);
            const placeholderContainer = document.querySelector(`#preview-${pipelineId}`).parentElement.querySelector('.preview-placeholder');
            
            if (thumbnailContainer && placeholderContainer) {
                thumbnailContainer.style.display = 'none';
                placeholderContainer.style.display = 'flex';
            }
        }
    } catch (error) {
        console.warn(`Error loading thumbnail for pipeline ${pipelineId}:`, error);
        // Show the default placeholder on error
        const thumbnailContainer = document.getElementById(`thumbnail-${pipelineId}`);
        const placeholderContainer = document.querySelector(`#preview-${pipelineId}`).parentElement.querySelector('.preview-placeholder');
        
        if (thumbnailContainer && placeholderContainer) {
            thumbnailContainer.style.display = 'none';
            placeholderContainer.style.display = 'flex';
        }
    }
}

// Force generation of a new thumbnail (for when stopping preview streams)
async function generateFreshThumbnail(pipelineId) {
    console.log(`Generating fresh thumbnail for pipeline ${pipelineId}`);
    try {
        // Force generation of a new thumbnail by calling the generate endpoint
        const response = await fetch(`/api/pipeline/${pipelineId}/thumbnail/generate`, {
            method: 'POST'
        });
        
        if (response.ok) {
            console.log(`Fresh thumbnail generated for ${pipelineId}`);
            // Now load the newly generated thumbnail
            await loadThumbnail(pipelineId);
        } else {
            console.warn(`Failed to generate fresh thumbnail for ${pipelineId}:`, response.statusText);
            // Fallback to loading existing thumbnail if generation fails
            await loadThumbnail(pipelineId);
        }
    } catch (error) {
        console.warn(`Error generating fresh thumbnail for pipeline ${pipelineId}:`, error);
        // Fallback to loading existing thumbnail if generation fails
        await loadThumbnail(pipelineId);
    }
}

function hideThumbnail(pipelineId) {
    const thumbnailContainer = document.getElementById(`thumbnail-${pipelineId}`);
    const placeholderContainer = document.querySelector(`#preview-${pipelineId}`).parentElement.querySelector('.preview-placeholder');
    
    if (thumbnailContainer && placeholderContainer) {
        thumbnailContainer.style.display = 'none';
        placeholderContainer.style.display = 'flex';
    }
}

function updateThumbnailVisibility(pipelineId, showLivePreview) {
    const thumbnailContainer = document.getElementById(`thumbnail-${pipelineId}`);
    const placeholderContainer = document.querySelector(`#preview-${pipelineId}`).parentElement.querySelector('.preview-placeholder');
    
    if (!showLivePreview && thumbnailContainer && placeholderContainer) {
        // Always try to load thumbnail when live preview is not showing (whether running or stopped)
        console.log(`updateThumbnailVisibility: Loading thumbnail for ${pipelineId}`);
        loadThumbnail(pipelineId);
    } else if (showLivePreview && thumbnailContainer) {
        // Hide thumbnail when live preview is active
        console.log(`updateThumbnailVisibility: Hiding thumbnail for ${pipelineId} (live preview active)`);
        hideThumbnail(pipelineId);
    }
}

// Force show thumbnail for stopped pipelines
function forceShowThumbnailForStopped(pipelineId) {
    console.log(`forceShowThumbnailForStopped: ${pipelineId}`);
    
    // Get pipeline status
    const pipeline = allPipelines.find(p => p.id === pipelineId);
    if (!pipeline) {
        console.warn(`Pipeline ${pipelineId} not found in allPipelines`);
        return;
    }
    
    if (pipeline.status === 'stopped') {
        console.log(`Pipeline ${pipelineId} is stopped, forcing thumbnail display`);
        
        // Make sure live preview is hidden
        const previewContainer = document.querySelector(`#preview-${pipelineId}`);
        if (previewContainer) {
            previewContainer.style.display = 'none';
        }
        
        // Load thumbnail
        loadThumbnail(pipelineId);
    }
}

// Pipeline details modal
async function showPipelineDetails(pipelineId) {
    currentDetailPipelineId = pipelineId;
    
    try {
        const response = await fetch(`/api/pipeline/${pipelineId}`);
        const pipeline = await response.json();
        
        if (response.ok) {
            renderPipelineDetails(pipeline);
            const modal = new bootstrap.Modal(document.getElementById('pipelineDetailsModal'));
            modal.show();
        } else {
            showAlert('error', 'Failed to load pipeline details');
        }
    } catch (error) {
        showAlert('error', 'Error loading pipeline details: ' + error.message);
    }
}

function renderPipelineDetails(pipeline) {
    const content = document.getElementById('pipelineDetailsContent');
    const createdDate = new Date(pipeline.created_date).toLocaleString();
    const modifiedDate = pipeline.modified_date ? new Date(pipeline.modified_date).toLocaleString() : 'Never';
    
    content.innerHTML = `
        <div class="row">
            <div class="col-md-6">
                <h6 class="text-light">Basic Information</h6>
                <table class="table table-sm table-dark">
                    <tr><td><strong>Name:</strong></td><td>${pipeline.name}</td></tr>
                    <tr><td><strong>Description:</strong></td><td>${pipeline.description || 'No description'}</td></tr>
                    <tr><td><strong>Status:</strong></td><td><span class="badge bg-${getStatusColor(pipeline.status)}">${capitalizeStatus(pipeline.status)}</span></td></tr>
                    <tr><td><strong>Inference:</strong></td><td>
                        <span class="badge ${pipeline.inference_enabled !== false ? 'bg-info' : 'bg-secondary'}">
                            <i class="fas fa-brain me-1"></i>
                            ${pipeline.inference_enabled !== false ? 'Enabled' : 'Disabled'}
                        </span>
                    </td></tr>
                    <tr><td><strong>Created:</strong></td><td>${createdDate}</td></tr>
                    <tr><td><strong>Modified:</strong></td><td>${modifiedDate}</td></tr>
                </table>
            </div>
            <div class="col-md-6">
                <h6 class="text-light">Performance Stats</h6>
                <table class="table table-sm table-dark">
                    <tr><td><strong>Total Frames:</strong></td><td>${pipeline.stats?.frame_count || 0}</td></tr>
                    <tr><td><strong>Total Inferences:</strong></td><td>${pipeline.stats?.inference_count || 0}</td></tr>
                    <tr><td><strong>FPS:</strong></td><td>${pipeline.stats?.fps || 0}</td></tr>
                    <tr><td><strong>Latency:</strong></td><td>${pipeline.stats?.latency_ms || 0}ms</td></tr>
                </table>
            </div>
        </div>
        
        <hr class="border-secondary">
        
        <div class="row">
            <div class="col-md-6">
                <h6 class="text-light">Frame Source Configuration</h6>
                <div class="card bg-dark border-secondary">
                    <div class="card-body">
                        <p class="text-light"><strong>Type:</strong> ${(pipeline.frame_source?.capture_type || pipeline.frame_source?.type || 'Unknown').replace('_', ' ').toUpperCase()}</p>
                        <pre class="small text-light bg-secondary p-2 rounded">${JSON.stringify(pipeline.frame_source?.config || {}, null, 2)}</pre>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <h6 class="text-light">Model Configuration</h6>
                <div class="card bg-dark border-secondary">
                    <div class="card-body">
                        <p class="text-light"><strong>Engine:</strong> ${pipeline.model?.engine_type || 'Unknown'}</p>
                        <p class="text-light"><strong>Device:</strong> ${pipeline.model?.device || 'Unknown'}</p>
                        <p class="text-light"><strong>Confidence:</strong> ${pipeline.model?.confidence_threshold || 'Default'}</p>
                        <p class="text-light"><strong>Model ID:</strong> ${pipeline.model?.id || 'Unknown'}</p>
                    </div>
                </div>
            </div>
        </div>
        
        <hr class="border-secondary">
        
        <h6 class="text-light">Result Destinations (${pipeline.destinations?.length || 0})</h6>
        <div class="row">
            ${(pipeline.destinations || []).map((dest, index) => `
                <div class="col-md-6 mb-2">
                    <div class="card bg-dark border-secondary">
                        <div class="card-body p-2">
                            <h6 class="card-title text-light">${dest.type.toUpperCase()}</h6>
                            <pre class="small mb-0 text-light bg-secondary p-2 rounded">${JSON.stringify(dest.config, null, 2)}</pre>
                        </div>
                    </div>
                </div>
            `).join('')}
        </div>
    `;
}

// Global control functions
async function startAllPipelines() {
    const stoppedPipelines = filteredPipelines.filter(p => p.status === 'stopped');
    
    if (stoppedPipelines.length === 0) {
        showAlert('info', 'No stopped pipelines to start in current view');
        return;
    }
    
    if (!confirm(`Start ${stoppedPipelines.length} filtered pipeline(s)?`)) {
        return;
    }
    
    // Show progress alert
    showAlert('info', `Starting ${stoppedPipelines.length} pipeline(s)...`);
    
    let successCount = 0;
    let errorCount = 0;
    let webcamPipelines = [];
    let otherPipelines = [];
    
    // Separate webcam pipelines from others to avoid conflicts
    stoppedPipelines.forEach(pipeline => {
        const frameSource = pipeline.frame_source || {};
        const type = frameSource.capture_type || frameSource.type || '';
        
        if (type === 'webcam') {
            webcamPipelines.push(pipeline);
        } else {
            otherPipelines.push(pipeline);
        }
    });
    
    // Start non-webcam pipelines first (they can run in parallel)
    for (const pipeline of otherPipelines) {
        try {
            const response = await fetch(`/api/pipeline/${pipeline.id}/start`, {
                method: 'POST'
            });
            
            if (response.ok) {
                successCount++;
                updateSinglePipelineState(pipeline.id, 'running');
            } else {
                const result = await response.json();
                errorCount++;
                console.error(`Failed to start pipeline ${pipeline.name}: ${result.error || 'Unknown error'}`);
            }
        } catch (error) {
            errorCount++;
            console.error(`Error starting pipeline ${pipeline.name}:`, error);
        }
        
        // Small delay between starts
        await new Promise(resolve => setTimeout(resolve, 200));
    }
    
    // Start webcam pipelines one at a time with longer delays to avoid conflicts
    for (const pipeline of webcamPipelines) {
        try {
            const response = await fetch(`/api/pipeline/${pipeline.id}/start`, {
                method: 'POST'
            });
            
            if (response.ok) {
                successCount++;
                updateSinglePipelineState(pipeline.id, 'running');
                
                // Wait longer for webcam initialization before starting next one
                await new Promise(resolve => setTimeout(resolve, 1500));
            } else {
                const result = await response.json();
                errorCount++;
                console.error(`Failed to start webcam pipeline ${pipeline.name}: ${result.error || 'Unknown error'}`);
                
                // Still wait a bit even on failure to avoid rapid retries
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        } catch (error) {
            errorCount++;
            console.error(`Error starting webcam pipeline ${pipeline.name}:`, error);
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }
    
    // Show final results
    if (successCount > 0 && errorCount === 0) {
        showAlert('success', `Successfully started all ${successCount} pipeline(s)`);
    } else if (successCount > 0 && errorCount > 0) {
        showAlert('warning', `Started ${successCount} pipeline(s) successfully, ${errorCount} failed to start`);
    } else {
        showAlert('error', `Failed to start all ${errorCount} pipeline(s)`);
    }
    
    // Refresh to update UI
    refreshPipelines(true);
}

async function stopAllPipelines() {
    const runningPipelines = filteredPipelines.filter(p => p.status === 'running');
    
    if (runningPipelines.length === 0) {
        showAlert('info', 'No running pipelines to stop in current view');
        return;
    }
    
    if (!confirm(`Stop ${runningPipelines.length} filtered pipeline(s)?`)) {
        return;
    }
    
    let successCount = 0;
    let errorCount = 0;
    
    for (const pipeline of runningPipelines) {
        try {
            const response = await fetch(`/api/pipeline/${pipeline.id}/stop`, {
                method: 'POST'
            });
            
            if (response.ok) {
                successCount++;
                
                // Stop preview if active
                if (activePreviews.has(pipeline.id)) {
                    stopPreviewStream(pipeline.id);
                    activePreviews.delete(pipeline.id);
                }
                
                updateSinglePipelineState(pipeline.id, 'stopped');
            } else {
                errorCount++;
                console.error(`Failed to stop pipeline ${pipeline.id}`);
            }
        } catch (error) {
            errorCount++;
            console.error(`Error stopping pipeline ${pipeline.id}:`, error);
        }
        
        // Add small delay to avoid overwhelming the server
        await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    if (successCount > 0) {
        showAlert('success', `Stopped ${successCount} pipeline(s) successfully`);
        refreshPipelines(true); // Update statistics
    }
    
    if (errorCount > 0) {
        showAlert('warning', `Failed to stop ${errorCount} pipeline(s)`);
    }
}

async function enableAllInference() {
    const runningPipelines = filteredPipelines.filter(p => p.status === 'running');
    
    if (runningPipelines.length === 0) {
        showAlert('info', 'No running pipelines found in current view');
        return;
    }
    
    const disabledInferencePipelines = runningPipelines.filter(p => p.inference_enabled === false);
    
    if (disabledInferencePipelines.length === 0) {
        showAlert('info', 'All running pipelines in current view already have inference enabled');
        return;
    }
    
    let successCount = 0;
    let errorCount = 0;
    
    for (const pipeline of disabledInferencePipelines) {
        try {
            const response = await fetch(`/api/pipeline/${pipeline.id}/inference/enable`, {
                method: 'POST'
            });
            
            if (response.ok) {
                successCount++;
                pipeline.inference_enabled = true;
                
                // Update inference toggle switch in card view
                const cardElement = document.querySelector(`[data-pipeline-id="${pipeline.id}"]`);
                if (cardElement) {
                    const inferenceBadge = cardElement.querySelector('.badge:nth-child(2)');
                    if (inferenceBadge) {
                        inferenceBadge.className = 'badge bg-info badge-sm';
                        inferenceBadge.innerHTML = 'Inference ON';
                    }
                    
                    // Update inference toggle switch
                    const inferenceToggle = cardElement.querySelector('.inference-toggle input');
                    if (inferenceToggle) {
                        inferenceToggle.checked = true;
                    }
                }
                
                // Update inference toggle switch in list view
                const rowElement = document.querySelector(`tr[data-pipeline-id="${pipeline.id}"]`);
                if (rowElement) {
                    const inferenceCell = rowElement.querySelector('td:nth-child(3)');
                    if (inferenceCell) {
                        inferenceCell.innerHTML = `
                            <div class="d-flex align-items-center justify-content-center">
                                <label class="inference-toggle compact">
                                    <input type="checkbox" 
                                           checked 
                                           onchange="toggleInference('${pipeline.id}', this.checked)">
                                    <span class="inference-slider"></span>
                                </label>
                            </div>
                        `;
                    }
                }
            } else {
                errorCount++;
                console.error(`Failed to enable inference for pipeline ${pipeline.id}`);
            }
        } catch (error) {
            errorCount++;
            console.error(`Error enabling inference for pipeline ${pipeline.id}:`, error);
        }
        
        // Add small delay to avoid overwhelming the server
        await new Promise(resolve => setTimeout(resolve, 50));
    }
    
    if (successCount > 0) {
        showAlert('success', `Enabled inference for ${successCount} pipeline(s)`);
    }
    
    if (errorCount > 0) {
        showAlert('warning', `Failed to enable inference for ${errorCount} pipeline(s)`);
    }
}

async function disableAllInference() {
    const runningPipelines = filteredPipelines.filter(p => p.status === 'running');
    
    if (runningPipelines.length === 0) {
        showAlert('info', 'No running pipelines found in current view');
        return;
    }
    
    const enabledInferencePipelines = runningPipelines.filter(p => p.inference_enabled !== false);
    
    if (enabledInferencePipelines.length === 0) {
        showAlert('info', 'All running pipelines in current view already have inference disabled');
        return;
    }
    
    let successCount = 0;
    let errorCount = 0;
    
    for (const pipeline of enabledInferencePipelines) {
        try {
            const response = await fetch(`/api/pipeline/${pipeline.id}/inference/disable`, {
                method: 'POST'
            });
            
            if (response.ok) {
                successCount++;
                pipeline.inference_enabled = false;
                
                // Update inference toggle switch in card view
                const cardElement = document.querySelector(`[data-pipeline-id="${pipeline.id}"]`);
                if (cardElement) {
                    const inferenceBadge = cardElement.querySelector('.badge:nth-child(2)');
                    if (inferenceBadge) {
                        inferenceBadge.className = 'badge bg-secondary badge-sm';
                        inferenceBadge.innerHTML = 'Inference OFF';
                    }
                    
                    // Update inference toggle switch
                    const inferenceToggle = cardElement.querySelector('.inference-toggle input');
                    if (inferenceToggle) {
                        inferenceToggle.checked = false;
                    }
                }
                
                // Update inference toggle switch in list view
                const rowElement = document.querySelector(`tr[data-pipeline-id="${pipeline.id}"]`);
                if (rowElement) {
                    const inferenceCell = rowElement.querySelector('td:nth-child(3)');
                    if (inferenceCell) {
                        inferenceCell.innerHTML = `
                            <div class="d-flex align-items-center justify-content-center">
                                <label class="inference-toggle compact">
                                    <input type="checkbox" 
                                           onchange="toggleInference('${pipeline.id}', this.checked)">
                                    <span class="inference-slider"></span>
                                </label>
                            </div>
                        `;
                    }
                }
            } else {
                errorCount++;
                console.error(`Failed to disable inference for pipeline ${pipeline.id}`);
            }
        } catch (error) {
            errorCount++;
            console.error(`Error disabling inference for pipeline ${pipeline.id}:`, error);
        }
        
        // Add small delay to avoid overwhelming the server
        await new Promise(resolve => setTimeout(resolve, 50));
    }
    
    if (successCount > 0) {
        showAlert('success', `Disabled inference for ${successCount} pipeline(s)`);
    }
    
    if (errorCount > 0) {
        showAlert('warning', `Failed to disable inference for ${errorCount} pipeline(s)`);
    }
}

function showAllPreviews() {
    const runningPipelines = filteredPipelines.filter(p => p.status === 'running');
    
    if (runningPipelines.length === 0) {
        showAlert('info', 'No running pipelines found in current view');
        return;
    }
    
    const pipelinesWithoutPreview = runningPipelines.filter(p => !activePreviews.has(p.id));
    
    if (pipelinesWithoutPreview.length === 0) {
        showAlert('info', 'All running pipelines in current view already have previews enabled');
        return;
    }
    
    if (currentViewMode === 'list') {
        // For list view, enable preview hover functionality
        pipelinesWithoutPreview.forEach(pipeline => {
            activePreviews.add(pipeline.id);
            
            const rowElement = document.querySelector(`tr[data-pipeline-id="${pipeline.id}"]`);
            
            // Update preview toggle switch in list view - DISABLED (preview toggles are hidden)
            /*
            const previewCell = rowElement?.querySelector('td:nth-child(4)');
            if (previewCell) {
                previewCell.innerHTML = `
                    <label class="preview-toggle compact">
                        <input type="checkbox" 
                               checked 
                               onchange="togglePreviewSwitch('${pipeline.id}', this.checked)">
                        <span class="preview-slider"></span>
                    </label>
                `;
            }
            */
            
            if (rowElement) {
                rowElement.className = 'preview-enabled';
                rowElement.onmouseenter = () => showListPreview(pipeline.id);
                rowElement.onmouseleave = () => hideListPreview();
            }
        });
    } else {
        // For card view, start preview streams
        pipelinesWithoutPreview.forEach(pipeline => {
            activePreviews.add(pipeline.id);
            startPreviewStream(pipeline.id);
            updatePreviewContainerVisibility(pipeline.id, true);
            
            // Update preview toggle switch in card view - DISABLED (preview toggles are hidden)
            /*
            const cardElement = document.querySelector(`[data-pipeline-id="${pipeline.id}"]`);
            const previewToggle = cardElement?.querySelector('.preview-toggle input');
            if (previewToggle) {
                previewToggle.checked = true;
            }
            */
        });
    }
    
    showAlert('success', `Enabled previews for ${pipelinesWithoutPreview.length} pipeline(s)`);
}

function hideAllPreviews() {
    // Only hide previews for pipelines that are currently visible (filtered)
    const filteredPipelineIds = new Set(filteredPipelines.map(p => p.id));
    const activeFilteredPreviews = Array.from(activePreviews).filter(id => filteredPipelineIds.has(id));
    
    if (activeFilteredPreviews.length === 0) {
        showAlert('info', 'No active previews to hide in current view');
        return;
    }
    
    const previewCount = activeFilteredPreviews.length;
    
    // Stop previews only for filtered pipelines
    activeFilteredPreviews.forEach(pipelineId => {
        if (currentViewMode === 'list') {
            // For list view, disable preview hover functionality
            const rowElement = document.querySelector(`tr[data-pipeline-id="${pipelineId}"]`);
            
            // Update preview toggle switch in list view - DISABLED (preview toggles are hidden)
            /*
            const previewCell = rowElement?.querySelector('td:nth-child(4)');
            if (previewCell) {
                previewCell.innerHTML = `
                    <label class="preview-toggle compact">
                        <input type="checkbox" 
                               onchange="togglePreviewSwitch('${pipelineId}', this.checked)">
                        <span class="preview-slider"></span>
                    </label>
                `;
            }
            */
            
            if (rowElement) {
                rowElement.className = '';
                rowElement.onmouseenter = null;
                rowElement.onmouseleave = null;
            }
        } else {
            // For card view, stop preview streams
            stopPreviewStream(pipelineId);
            updatePreviewContainerVisibility(pipelineId, false);
            
            // Update preview toggle switch in card view - DISABLED (preview toggles are hidden)
            /*
            const cardElement = document.querySelector(`[data-pipeline-id="${pipelineId}"]`);
            const previewToggle = cardElement?.querySelector('.preview-toggle input');
            if (previewToggle) {
                previewToggle.checked = false;
            }
            */
        }
        
        // Remove this pipeline from active previews
        activePreviews.delete(pipelineId);
    });
    
    // Hide list preview overlay if visible
    hideListPreview();
    
    showAlert('success', `Disabled previews for ${previewCount} pipeline(s) in current view`);
}

// Import pipeline function
function importPipeline() {
    const fileInput = document.getElementById('pipelineImportInput');
    
    // Set up event listener for file selection
    fileInput.onchange = async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // Validate file type
        if (!file.name.endsWith('.zip')) {
            showAlert('error', 'Please select a ZIP file containing a pipeline export');
            return;
        }
        
        try {
            // Show loading state
            showAlert('info', 'Importing pipeline...');
            
            // Create form data
            const formData = new FormData();
            formData.append('file', file);
            
            // Upload and import
            const response = await fetch('/api/pipeline/import', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (response.ok) {
                showAlert('success', `Pipeline "${result.pipeline_name}" imported successfully`);
                
                // Refresh pipelines to show the new import
                refreshPipelines();
            } else {
                showAlert('error', `Failed to import pipeline: ${result.error}`);
            }
            
        } catch (error) {
            showAlert('error', `Error importing pipeline: ${error.message}`);
        }
        
        // Reset file input
        fileInput.value = '';
    };
    
    // Trigger file selection dialog
    fileInput.click();
}

// Publisher control functions
async function togglePublisher(pipelineId, publisherId, enabled) {
    try {
        const action = enabled ? 'enable' : 'disable';
        const response = await fetch(`/api/pipeline/${pipelineId}/publisher/${publisherId}/${action}`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (response.ok) {
            showAlert('success', `Publisher ${enabled ? 'enabled' : 'disabled'} successfully`);
            
            // Update local pipeline data
            const pipeline = allPipelines.find(p => p.id === pipelineId);
            if (pipeline && pipeline.destinations) {
                const destination = pipeline.destinations.find(dest => dest.id === publisherId);
                if (destination) {
                    destination.enabled = enabled;
                }
            }
            
            // Update the UI immediately without full refresh
            updatePublisherStateInUI(pipelineId, publisherId, enabled);
            
        } else {
            showAlert('error', `Failed to ${action} publisher: ${result.error}`);
            // Revert the toggle
            const toggle = document.querySelector(`input[onchange*="${publisherId}"]`);
            if (toggle) {
                toggle.checked = !enabled;
            }
        }
    } catch (error) {
        showAlert('error', `Error ${enabled ? 'enabling' : 'disabling'} publisher: ${error.message}`);
        // Revert the toggle
        const toggle = document.querySelector(`input[onchange*="${publisherId}"]`);
        if (toggle) {
            toggle.checked = !enabled;
        }
    }
}

function updatePublisherStateInUI(pipelineId, publisherId, enabled) {
    // Find the pipeline card
    const cardElement = document.querySelector(`[data-pipeline-id="${pipelineId}"]`);
    if (cardElement) {
        // For now, just refresh the pipelines to get the most current state
        // This ensures all failure information is properly displayed
        refreshPipelines(true);
    }
    
    // Also update list view if it exists
    const rowElement = document.querySelector(`tr[data-pipeline-id="${pipelineId}"]`);
    if (rowElement) {
        // In list view, we would need to update publisher information if displayed
        // For now, this is primarily handled in card view through refresh
    }
}

// Load available inference engines to populate dynamic filter badges
async function loadAvailableEngineTypes() {
    try {
        const response = await fetch('/api/inference/engines');
        if (response.ok) {
            const data = await response.json();
            availableEngineTypes = data.engine_types;
            updateEngineQuickFilterBadges();
        } else {
            console.error('Failed to load engine types');
        }
    } catch (error) {
        console.error('Error loading engine types:', error);
    }
}

// Update engine quick filter badges based on available engines
function updateEngineQuickFilterBadges() {
    // Find the engine filter badges container
    const container = document.querySelector('.quick-search-badges');
    if (!container) return;
    
    // Find existing engine badges (between the first and second separator)
    const separators = container.querySelectorAll('.filter-separator');
    if (separators.length < 2) return;
    
    const firstSeparator = separators[0];
    const secondSeparator = separators[1];
    
    // Remove existing engine badges
    let currentElement = firstSeparator.nextElementSibling;
    while (currentElement && currentElement !== secondSeparator) {
        const nextElement = currentElement.nextElementSibling;
        currentElement.remove();
        currentElement = nextElement;
    }
    
    // Add new engine badges
    const availableEngines = availableEngineTypes
        .filter(engine => engine.available && engine.primary)
        .slice(0, 4); // Limit to 4 badges
    
    let insertAfter = firstSeparator;
    availableEngines.forEach(engine => {
        const badge = document.createElement('span');
        badge.className = 'quick-search-badge';
        badge.onclick = () => toggleQuickFilter(engine.type);
        badge.title = `Toggle ${engine.name} pipelines filter`;
        badge.textContent = engine.type;
        badge.setAttribute('data-filter-term', engine.type); // Store filter term for active state handling
        
        insertAfter.insertAdjacentElement('afterend', badge);
        insertAfter = badge;
    });
}

// Initialize view mode from saved preference
function initializeViewMode() {
    // Update radio button states based on saved preference
    const cardViewRadio = document.getElementById('cardView');
    const listViewRadio = document.getElementById('listView');
    
    if (currentViewMode === 'list') {
        cardViewRadio.checked = false;
        listViewRadio.checked = true;
    } else {
        cardViewRadio.checked = true;
        listViewRadio.checked = false;
    }
    
    // Apply the saved view mode
    toggleViewMode(currentViewMode);
}

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    // Initialize view mode first, before loading pipelines
    initializeViewMode();
    
    refreshPipelines();
    loadAvailableEngineTypes(); // Load engines for dynamic filtering
    
    // Auto-refresh pipelines every 30 seconds (preserve previews)
    setInterval(() => refreshPipelines(true), 30000);
    
    // Update metrics more frequently (every 1 second) using lightweight endpoint
    setInterval(updatePipelineMetrics, 1000);
    
    // Safety mechanism: Hide any stuck list preview when clicking anywhere
    document.addEventListener('click', function(event) {
        const overlay = document.getElementById('listPreviewOverlay');
        if (overlay && overlay.classList.contains('show')) {
            // Don't hide if clicking on a table row with preview enabled
            const clickedRow = event.target.closest('tr[data-pipeline-id]');
            if (!clickedRow || !clickedRow.classList.contains('preview-enabled')) {
                hideListPreview();
            }
        }
    });
    
    // Also hide preview when pressing Escape key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            hideListPreview();
        }
    });
});
</script>
{% endblock %}
